// Code generated by goagen v1.4.3, DO NOT EDIT.
//
// API "Vulcan-API": CLI Commands
//
// Command:
// $ main

package cli

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/adevinta/vulcan-api/cmd/vulcan-api-cli/client"
	"github.com/goadesign/goa"
	goaclient "github.com/goadesign/goa/client"
	uuid "github.com/goadesign/goa/uuid"
	"github.com/spf13/cobra"
	"log"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"
)

type (
	// CreateAPITokenCommand is the command line data structure for the create action of api-token
	CreateAPITokenCommand struct {
		// User ID
		UserID      string
		PrettyPrint bool
	}

	// CreateTeamsCommand is the command line data structure for the create action of teams
	CreateTeamsCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// DeleteTeamsCommand is the command line data structure for the delete action of teams
	DeleteTeamsCommand struct {
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListTeamsCommand is the command line data structure for the list action of teams
	ListTeamsCommand struct {
		// Team tag
		Tag         string
		PrettyPrint bool
	}

	// ShowTeamsCommand is the command line data structure for the show action of teams
	ShowTeamsCommand struct {
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdateTeamsCommand is the command line data structure for the update action of teams
	UpdateTeamsCommand struct {
		Payload     string
		ContentType string
		// team ID
		TeamID      string
		PrettyPrint bool
	}

	// CreateAssetsCommand is the command line data structure for the create action of assets
	CreateAssetsCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CreateMultiStatusAssetsCommand is the command line data structure for the createMultiStatus action of assets
	CreateMultiStatusAssetsCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeleteAssetsCommand is the command line data structure for the delete action of assets
	DeleteAssetsCommand struct {
		// Asset ID
		AssetID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DiscoverAssetsCommand is the command line data structure for the discover action of assets
	DiscoverAssetsCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListAssetsCommand is the command line data structure for the list action of assets
	ListAssetsCommand struct {
		// Team ID
		TeamID string
		// Identifier
		Identifier  string
		PrettyPrint bool
	}

	// ShowAssetsCommand is the command line data structure for the show action of assets
	ShowAssetsCommand struct {
		// Asset ID
		AssetID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdateAssetsCommand is the command line data structure for the update action of assets
	UpdateAssetsCommand struct {
		Payload     string
		ContentType string
		// Asset ID
		AssetID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CreateAssetAnnotationsCommand is the command line data structure for the create action of asset-annotations
	CreateAssetAnnotationsCommand struct {
		Payload     string
		ContentType string
		// Asset ID
		AssetID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeleteAssetAnnotationsCommand is the command line data structure for the delete action of asset-annotations
	DeleteAssetAnnotationsCommand struct {
		Payload     string
		ContentType string
		// Asset ID
		AssetID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListAssetAnnotationsCommand is the command line data structure for the list action of asset-annotations
	ListAssetAnnotationsCommand struct {
		// Asset ID
		AssetID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// PutAssetAnnotationsCommand is the command line data structure for the put action of asset-annotations
	PutAssetAnnotationsCommand struct {
		Payload     string
		ContentType string
		// Asset ID
		AssetID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdateAssetAnnotationsCommand is the command line data structure for the update action of asset-annotations
	UpdateAssetAnnotationsCommand struct {
		Payload     string
		ContentType string
		// Asset ID
		AssetID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CreateAssetGroupCommand is the command line data structure for the create action of asset-group
	CreateAssetGroupCommand struct {
		Payload     string
		ContentType string
		// Group ID
		GroupID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeleteAssetGroupCommand is the command line data structure for the delete action of asset-group
	DeleteAssetGroupCommand struct {
		// Asset ID
		AssetID string
		// Group ID
		GroupID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListAssetGroupCommand is the command line data structure for the list action of asset-group
	ListAssetGroupCommand struct {
		// Group ID
		GroupID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// FindFindingFindingsCommand is the command line data structure for the Find finding action of findings
	FindFindingFindingsCommand struct {
		// Finding ID
		FindingID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// FindFindingsFromAIssueFindingsCommand is the command line data structure for the Find findings from a Issue action of findings
	FindFindingsFromAIssueFindingsCommand struct {
		// Issue ID
		IssueID string
		// Team ID
		TeamID string
		// Allows to get findings list at a specific date (incompatible and preferential to min and max date params)
		AtDate string
		// A comma separated list of identifiers
		Identifiers string
		// A comma separated list of associated labels
		Labels string
		// Allows to get findings list until a specific date
		MaxDate string
		// Findings maximum score
		MaxScore string
		// Allows to get findings list from a specific date
		MinDate string
		// Findings minimum score
		MinScore string
		// Requested page
		Page string
		// Requested page size
		Size string
		// Sorting criteria. Supported fields: score, -score (for descending order)
		SortBy string
		// Findings Status
		Status      string
		PrettyPrint bool
	}

	// FindFindingsFromATargetFindingsCommand is the command line data structure for the Find findings from a Target action of findings
	FindFindingsFromATargetFindingsCommand struct {
		// Target ID
		TargetID string
		// Team ID
		TeamID string
		// Allows to get findings list at a specific date (incompatible and preferential to min and max date params)
		AtDate string
		// A comma separated list of identifiers
		Identifiers string
		// A comma separated list of associated labels
		Labels string
		// Allows to get findings list until a specific date
		MaxDate string
		// Findings maximum score
		MaxScore string
		// Allows to get findings list from a specific date
		MinDate string
		// Findings minimum score
		MinScore string
		// Requested page
		Page string
		// Requested page size
		Size string
		// Sorting criteria. Supported fields: score, -score (for descending order)
		SortBy string
		// Findings Status
		Status      string
		PrettyPrint bool
	}

	// ListFindingOverwritesFindingsCommand is the command line data structure for the List Finding Overwrites action of findings
	ListFindingOverwritesFindingsCommand struct {
		FindingID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListFindingsLabelsFindingsCommand is the command line data structure for the List findings labels action of findings
	ListFindingsLabelsFindingsCommand struct {
		// Team ID
		TeamID string
		// Allows to get findings list at a specific date (incompatible and preferential to min and max date params)
		AtDate string
		// A comma separated list of identifiers
		Identifiers string
		// Allows to get findings list until a specific date
		MaxDate string
		// Allows to get findings list from a specific date
		MinDate string
		// Findings status
		Status      string
		PrettyPrint bool
	}

	// SubmitAFindingOverwriteFindingsCommand is the command line data structure for the Submit a Finding Overwrite action of findings
	SubmitAFindingOverwriteFindingsCommand struct {
		Payload     string
		ContentType string
		FindingID   string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListFindingsFindingsCommand is the command line data structure for the list findings action of findings
	ListFindingsFindingsCommand struct {
		// Team ID
		TeamID string
		// Allows to get findings list at a specific date (incompatible and preferential to min and max date params)
		AtDate string
		// Allows to get findings list for a specific asset identifier
		Identifier string
		// A comma separated list of identifiers
		Identifiers string
		// Issue ID (Vulnerability DB)
		IssueID string
		// A comma separated list of associated labels
		Labels string
		// Allows to get findings list until a specific date
		MaxDate string
		// Findings maximum score
		MaxScore string
		// Allows to get findings list from a specific date
		MinDate string
		// Findings minimum score
		MinScore string
		// Requested page
		Page string
		// Requested page size
		Size string
		// Sorting criteria. Supported fields: score, -score (for descending order)
		SortBy string
		// Findings Status
		Status string
		// Target ID (Vulnerability DB)
		TargetID    string
		PrettyPrint bool
	}

	// ListFindingsIssuesFindingsCommand is the command line data structure for the list findings issues action of findings
	ListFindingsIssuesFindingsCommand struct {
		// Team ID
		TeamID string
		// Allows to get issues list at a specific date
		AtDate string
		// A comma separated list of identifiers
		Identifiers string
		// A comma separated list of associated labels
		Labels string
		// Allows to get findings list until a specific date
		MaxDate string
		// Allows to get findings list from a specific date
		MinDate string
		// Requested page
		Page string
		// Requested page size
		Size string
		// Sorting criteria. Supported fields: max_score, targets_count (use - for descending order. E.g.: -max_score)
		SortBy string
		// Findings Status
		Status string
		// Target ID (Vulnerability DB)
		TargetID    string
		PrettyPrint bool
	}

	// ListFindingsTargetsFindingsCommand is the command line data structure for the list findings targets action of findings
	ListFindingsTargetsFindingsCommand struct {
		// Team ID
		TeamID string
		// Allows to get targets list at a specific date
		AtDate string
		// A comma separated list of identifiers
		Identifiers string
		// Issue ID (Vulnerability DB)
		IssueID string
		// A comma separated list of associated labels
		Labels string
		// Allows to get findings list until a specific date
		MaxDate string
		// Allows to get findings list from a specific date
		MinDate string
		// Requested page
		Page string
		// Requested page size
		Size string
		// Sorting criteria. Supported fields: max_score, findings_count (use - for descending order. E.g.: -max_score)
		SortBy string
		// Findings Status
		Status      string
		PrettyPrint bool
	}

	// AssetsGlobalStatsCommand is the command line data structure for the assets action of global-stats
	AssetsGlobalStatsCommand struct {
		// A comma separated list of asset identifiers
		Identifiers string
		// A comma separated list of associated labels
		Labels string
		// Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.
		Tags        string
		PrettyPrint bool
	}

	// CurrentExposureGlobalStatsCommand is the command line data structure for the current exposure action of global-stats
	CurrentExposureGlobalStatsCommand struct {
		// Maximum issues score filter
		MaxScore string
		// Minimum issues score filter
		MinScore string
		// Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.
		Tags        string
		PrettyPrint bool
	}

	// ExposureGlobalStatsCommand is the command line data structure for the exposure action of global-stats
	ExposureGlobalStatsCommand struct {
		// Specific date to get statistics at
		AtDate string
		// Maximum issues score filter
		MaxScore string
		// Minimum issues score filter
		MinScore string
		// Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.
		Tags        string
		PrettyPrint bool
	}

	// FixedGlobalStatsCommand is the command line data structure for the fixed action of global-stats
	FixedGlobalStatsCommand struct {
		// Specific date to get statistics at (incompatible and preferential to min and max date params)
		AtDate string
		// A comma separated list of asset identifiers
		Identifiers string
		// A comma separated list of associated labels
		Labels string
		// Maximum date to filter statistics by
		MaxDate string
		// Minimum date to filter statistics by
		MinDate string
		// Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.
		Tags        string
		PrettyPrint bool
	}

	// MttrGlobalStatsCommand is the command line data structure for the mttr action of global-stats
	MttrGlobalStatsCommand struct {
		// Maximum date to filter statistics by
		MaxDate string
		// Minimum date to filter statistics by
		MinDate string
		// Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.
		Tags        string
		PrettyPrint bool
	}

	// OpenGlobalStatsCommand is the command line data structure for the open action of global-stats
	OpenGlobalStatsCommand struct {
		// Specific date to get statistics at (incompatible and preferential to min and max date params)
		AtDate string
		// A comma separated list of asset identifiers
		Identifiers string
		// A comma separated list of associated labels
		Labels string
		// Maximum date to filter statistics by
		MaxDate string
		// Minimum date to filter statistics by
		MinDate string
		// Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.
		Tags        string
		PrettyPrint bool
	}

	// CreateGroupCommand is the command line data structure for the create action of group
	CreateGroupCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeleteGroupCommand is the command line data structure for the delete action of group
	DeleteGroupCommand struct {
		// Group ID
		GroupID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListGroupCommand is the command line data structure for the list action of group
	ListGroupCommand struct {
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ShowGroupCommand is the command line data structure for the show action of group
	ShowGroupCommand struct {
		// Group ID
		GroupID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdateGroupCommand is the command line data structure for the update action of group
	UpdateGroupCommand struct {
		Payload     string
		ContentType string
		// Group ID
		GroupID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ShowHealthcheckCommand is the command line data structure for the show action of healthcheck
	ShowHealthcheckCommand struct {
		PrettyPrint bool
	}

	// ShowJobsCommand is the command line data structure for the show action of jobs
	ShowJobsCommand struct {
		// Job ID
		JobID       string
		PrettyPrint bool
	}

	// CreatePoliciesCommand is the command line data structure for the create action of policies
	CreatePoliciesCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeletePoliciesCommand is the command line data structure for the delete action of policies
	DeletePoliciesCommand struct {
		// Policy ID
		PolicyID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListPoliciesCommand is the command line data structure for the list action of policies
	ListPoliciesCommand struct {
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ShowPoliciesCommand is the command line data structure for the show action of policies
	ShowPoliciesCommand struct {
		// Policy ID
		PolicyID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdatePoliciesCommand is the command line data structure for the update action of policies
	UpdatePoliciesCommand struct {
		Payload     string
		ContentType string
		// Policy ID
		PolicyID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CreatePolicySettingsCommand is the command line data structure for the create action of policy-settings
	CreatePolicySettingsCommand struct {
		Payload     string
		ContentType string
		// Policy ID
		PolicyID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeletePolicySettingsCommand is the command line data structure for the delete action of policy-settings
	DeletePolicySettingsCommand struct {
		// Policy ID
		PolicyID string
		// Policy Settings ID
		SettingsID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListPolicySettingsCommand is the command line data structure for the list action of policy-settings
	ListPolicySettingsCommand struct {
		// Policy ID
		PolicyID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ShowPolicySettingsCommand is the command line data structure for the show action of policy-settings
	ShowPolicySettingsCommand struct {
		// Policy ID
		PolicyID string
		// CheckType Settings ID
		SettingsID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdatePolicySettingsCommand is the command line data structure for the update action of policy-settings
	UpdatePolicySettingsCommand struct {
		Payload     string
		ContentType string
		// Policy ID
		PolicyID string
		// Policy Settings ID
		SettingsID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CreateProgramsCommand is the command line data structure for the create action of programs
	CreateProgramsCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeleteProgramsCommand is the command line data structure for the delete action of programs
	DeleteProgramsCommand struct {
		// Program ID
		ProgramID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListProgramsCommand is the command line data structure for the list action of programs
	ListProgramsCommand struct {
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ShowProgramsCommand is the command line data structure for the show action of programs
	ShowProgramsCommand struct {
		// Program ID
		ProgramID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdateProgramsCommand is the command line data structure for the update action of programs
	UpdateProgramsCommand struct {
		Payload     string
		ContentType string
		// Program ID
		ProgramID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListProgramScansCommand is the command line data structure for the list action of program-scans
	ListProgramScansCommand struct {
		// Program ID
		ProgramID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ListRecipientsCommand is the command line data structure for the list action of recipients
	ListRecipientsCommand struct {
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdateRecipientsCommand is the command line data structure for the update action of recipients
	UpdateRecipientsCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// SendDigestReportCommand is the command line data structure for the send digest action of report
	SendDigestReportCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CreateScanCommand is the command line data structure for the create action of scan
	CreateScanCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ShowScanCommand is the command line data structure for the show action of scan
	ShowScanCommand struct {
		// Scan ID
		ScanID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// EmailScanReportCommand is the command line data structure for the email action of scan report
	EmailScanReportCommand struct {
		// Scan ID
		ScanID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// GenerateScanReportCommand is the command line data structure for the generate action of scan report
	GenerateScanReportCommand struct {
		// Scan ID
		ScanID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// SendScanReportCommand is the command line data structure for the send action of scan report
	SendScanReportCommand struct {
		// Scan ID
		ScanID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ShowScanReportCommand is the command line data structure for the show action of scan report
	ShowScanReportCommand struct {
		// Scan ID
		ScanID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CreateScheduleCommand is the command line data structure for the create action of schedule
	CreateScheduleCommand struct {
		Payload     string
		ContentType string
		// Program ID
		ProgramID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeleteScheduleCommand is the command line data structure for the delete action of schedule
	DeleteScheduleCommand struct {
		// Program ID
		ProgramID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// UpdateScheduleCommand is the command line data structure for the update action of schedule
	UpdateScheduleCommand struct {
		Payload     string
		ContentType string
		// Program ID
		ProgramID string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CoverageStatsCommand is the command line data structure for the coverage action of stats
	CoverageStatsCommand struct {
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// CurrentExposureStatsCommand is the command line data structure for the current exposure action of stats
	CurrentExposureStatsCommand struct {
		// Team ID
		TeamID string
		// Maximum issues score filter
		MaxScore string
		// Minimum issues score filter
		MinScore    string
		PrettyPrint bool
	}

	// ExposureStatsCommand is the command line data structure for the exposure action of stats
	ExposureStatsCommand struct {
		// Team ID
		TeamID string
		// Specific date to get statistics at
		AtDate string
		// Maximum issues score filter
		MaxScore string
		// Minimum issues score filter
		MinScore    string
		PrettyPrint bool
	}

	// FixedStatsCommand is the command line data structure for the fixed action of stats
	FixedStatsCommand struct {
		// Team ID
		TeamID string
		// Specific date to get statistics at (incompatible and preferential to min and max date params)
		AtDate string
		// A comma separated list of asset identifiers
		Identifiers string
		// A comma separated list of associated labels
		Labels string
		// Maximum date to filter statistics by
		MaxDate string
		// Minimum date to filter statistics by
		MinDate     string
		PrettyPrint bool
	}

	// MttrStatsCommand is the command line data structure for the mttr action of stats
	MttrStatsCommand struct {
		// Team ID
		TeamID string
		// Maximum date to filter statistics by
		MaxDate string
		// Minimum date to filter statistics by
		MinDate     string
		PrettyPrint bool
	}

	// OpenStatsCommand is the command line data structure for the open action of stats
	OpenStatsCommand struct {
		// Team ID
		TeamID string
		// Specific date to get statistics at (incompatible and preferential to min and max date params)
		AtDate string
		// A comma separated list of asset identifiers
		Identifiers string
		// A comma separated list of associated labels
		Labels string
		// Maximum date to filter statistics by
		MaxDate string
		// Minimum date to filter statistics by
		MinDate     string
		PrettyPrint bool
	}

	// CreateTeamMembersCommand is the command line data structure for the create action of team-members
	CreateTeamMembersCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// DeleteTeamMembersCommand is the command line data structure for the delete action of team-members
	DeleteTeamMembersCommand struct {
		// Team ID
		TeamID string
		// User ID
		UserID      string
		PrettyPrint bool
	}

	// ListTeamMembersCommand is the command line data structure for the list action of team-members
	ListTeamMembersCommand struct {
		// Team ID
		TeamID      string
		PrettyPrint bool
	}

	// ShowTeamMembersCommand is the command line data structure for the show action of team-members
	ShowTeamMembersCommand struct {
		// Team ID
		TeamID string
		// User ID
		UserID      string
		PrettyPrint bool
	}

	// UpdateTeamMembersCommand is the command line data structure for the update action of team-members
	UpdateTeamMembersCommand struct {
		Payload     string
		ContentType string
		// Team ID
		TeamID string
		// User ID
		UserID      string
		PrettyPrint bool
	}

	// CreateUserCommand is the command line data structure for the create action of user
	CreateUserCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// DeleteUserCommand is the command line data structure for the delete action of user
	DeleteUserCommand struct {
		// User ID
		UserID      string
		PrettyPrint bool
	}

	// ListUserCommand is the command line data structure for the list action of user
	ListUserCommand struct {
		PrettyPrint bool
	}

	// ListTeamsUserCommand is the command line data structure for the list-teams action of user
	ListTeamsUserCommand struct {
		// User ID
		UserID      string
		PrettyPrint bool
	}

	// ProfileUserCommand is the command line data structure for the profile action of user
	ProfileUserCommand struct {
		PrettyPrint bool
	}

	// ShowUserCommand is the command line data structure for the show action of user
	ShowUserCommand struct {
		// User ID
		UserID      string
		PrettyPrint bool
	}

	// UpdateUserCommand is the command line data structure for the update action of user
	UpdateUserCommand struct {
		Payload     string
		ContentType string
		// User ID
		UserID      string
		PrettyPrint bool
	}
)

// RegisterCommands registers the resource action CLI commands.
func RegisterCommands(app *cobra.Command, c *client.Client) {
	var command, sub *cobra.Command
	command = &cobra.Command{
		Use:   "assets",
		Short: `Get global assets per severity statistics.`,
	}
	tmp1 := new(AssetsGlobalStatsCommand)
	sub = &cobra.Command{
		Use:   `global-stats ["/api/v1/stats/assets"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp1.Run(c, args) },
	}
	tmp1.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp1.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "coverage",
		Short: `Get asset coverage for a team.`,
	}
	tmp2 := new(CoverageStatsCommand)
	sub = &cobra.Command{
		Use:   `stats ["/api/v1/teams/TEAM_ID/stats/coverage"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp2.Run(c, args) },
	}
	tmp2.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp2.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "create",
		Short: `create action`,
	}
	tmp3 := new(CreateAPITokenCommand)
	sub = &cobra.Command{
		Use:   `api-token ["/api/v1/users/USER_ID/token"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp3.Run(c, args) },
	}
	tmp3.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp3.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp4 := new(CreateAssetsCommand)
	sub = &cobra.Command{
		Use:   `assets ["/api/v1/teams/TEAM_ID/assets"]`,
		Short: ``,
		Long: `

Payload example:

{
   "annotations": {
      "annotation/1": "value/1",
      "annotation/2": "value/2"
   },
   "assets": [
      {
         "alias": "AnAlias",
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      },
      {
         "alias": "AnAlias",
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      },
      {
         "alias": "AnAlias",
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      }
   ],
   "groups": [
      "a14c7c65-66ab-4676-bcf6-0dea9719f5c6",
      "9f7a0c78-b752-4126-aa6d-0f286ada7b8f"
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp4.Run(c, args) },
	}
	tmp4.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp4.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp5 := new(CreateAssetAnnotationsCommand)
	sub = &cobra.Command{
		Use:   `asset-annotations ["/api/v1/teams/TEAM_ID/assets/ASSET_ID/annotations"]`,
		Short: ``,
		Long: `

Payload example:

{
   "annotations": {
      "annotation/1": "value/1",
      "annotation/2": "value/2"
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp5.Run(c, args) },
	}
	tmp5.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp5.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp6 := new(CreateAssetGroupCommand)
	sub = &cobra.Command{
		Use:   `asset-group ["/api/v1/teams/TEAM_ID/groups/GROUP_ID/assets"]`,
		Short: ``,
		Long: `

Payload example:

{
   "asset_id": "0fc67150-5cd9-486a-aca5-9c9167478e4d"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp6.Run(c, args) },
	}
	tmp6.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp6.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp7 := new(CreateTeamsCommand)
	sub = &cobra.Command{
		Use:   `teams ["/api/v1/teams"]`,
		Short: ``,
		Long: `

Payload example:

{
   "description": "Security Team",
   "name": "Security",
   "tag": "team:security"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp7.Run(c, args) },
	}
	tmp7.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp7.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp8 := new(CreateGroupCommand)
	sub = &cobra.Command{
		Use:   `group ["/api/v1/teams/TEAM_ID/groups"]`,
		Short: ``,
		Long: `

Payload example:

{
   "name": "Default group",
   "options": "{\"timeout\":60}"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp8.Run(c, args) },
	}
	tmp8.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp8.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp9 := new(CreatePoliciesCommand)
	sub = &cobra.Command{
		Use:   `policies ["/api/v1/teams/TEAM_ID/policies"]`,
		Short: ``,
		Long: `

Payload example:

{
   "name": "Sample Policy"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp9.Run(c, args) },
	}
	tmp9.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp9.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp10 := new(CreatePolicySettingsCommand)
	sub = &cobra.Command{
		Use:   `policy-settings ["/api/v1/teams/TEAM_ID/policies/POLICY_ID/settings"]`,
		Short: ``,
		Long: `

Payload example:

{
   "checktype_name": "vulcan-tls",
   "options": "{\"timeout\":60}"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp10.Run(c, args) },
	}
	tmp10.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp10.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp11 := new(CreateProgramsCommand)
	sub = &cobra.Command{
		Use:   `programs ["/api/v1/teams/TEAM_ID/programs"]`,
		Short: ``,
		Long: `

Payload example:

{
   "autosend": true,
   "disabled": false,
   "name": "Every midnight",
   "policy_groups": [
      {
         "group_id": "Iure provident.",
         "policy_id": "Consequatur perferendis dolor."
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp11.Run(c, args) },
	}
	tmp11.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp11.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp12 := new(CreateScanCommand)
	sub = &cobra.Command{
		Use:   `scan ["/api/v1/teams/TEAM_ID/scans"]`,
		Short: ``,
		Long: `

Payload example:

{
   "program_id": "1bb4c953-245e-477b-b005-400f319274f2",
   "scheduled_time": "2018-09-07T10:40:52Z"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp12.Run(c, args) },
	}
	tmp12.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp12.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp13 := new(CreateScheduleCommand)
	sub = &cobra.Command{
		Use:   `schedule ["/api/v1/teams/TEAM_ID/programs/PROGRAM_ID/schedule"]`,
		Short: ``,
		Long: `

Payload example:

{
   "cron": "0 7 1 * *"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp13.Run(c, args) },
	}
	tmp13.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp13.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp14 := new(CreateTeamMembersCommand)
	sub = &cobra.Command{
		Use:   `team-members ["/api/v1/teams/TEAM_ID/members"]`,
		Short: ``,
		Long: `

Payload example:

{
   "email": "john.doe@vulcan.example.com",
   "role": "owner",
   "user_id": "967d9966-b561-4233-bd6f-cac603fd8320"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp14.Run(c, args) },
	}
	tmp14.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp14.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp15 := new(CreateUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/v1/users"]`,
		Short: ``,
		Long: `

Payload example:

{
   "active": true,
   "admin": false,
   "email": "john.doe@vulcan.example.com",
   "firstname": "John",
   "lastname": "Doe",
   "observer": false
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp15.Run(c, args) },
	}
	tmp15.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp15.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "create-multi-status",
		Short: `Creates assets in bulk mode (MultiStatus).
			This operation is similar to the "Create Assets in Bulk Mode", with 2 main differences:
			- This endpoint is not atomic. Each asset creation request will succeed or fail indenpendently of the other requests.
			- This endpoint will return an array of AssetResponse in the following way:
				· For each asset with specified type, returns an AssetResponse indicating the success or failure for its creation.
				· For each asset with no type specified and successfully created, returns one AssetResponse for each auto detected asset.
				· For each asset with no type specified which its creation produced an error, returns one AssetResponse indicating the failure for the creation of its detected assets without specifying which exact type failed.
			In the case of all assets being successfully created, this endpoint will return status code 201-Created. 
			Otherwise, it will return a 207-MultiStatus code, indicating that at least one of the requested operations failed.	
		`,
	}
	tmp16 := new(CreateMultiStatusAssetsCommand)
	sub = &cobra.Command{
		Use:   `assets ["/api/v1/teams/TEAM_ID/assets/multistatus"]`,
		Short: ``,
		Long: `

Payload example:

{
   "annotations": {
      "annotation/1": "value/1",
      "annotation/2": "value/2"
   },
   "assets": [
      {
         "alias": "AnAlias",
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      },
      {
         "alias": "AnAlias",
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      },
      {
         "alias": "AnAlias",
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      }
   ],
   "groups": [
      "a14c7c65-66ab-4676-bcf6-0dea9719f5c6",
      "9f7a0c78-b752-4126-aa6d-0f286ada7b8f"
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp16.Run(c, args) },
	}
	tmp16.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp16.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "current-exposure",
		Short: `currentExposure action`,
	}
	tmp17 := new(CurrentExposureGlobalStatsCommand)
	sub = &cobra.Command{
		Use:   `global-stats ["/api/v1/stats/exposure/current"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp17.Run(c, args) },
	}
	tmp17.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp17.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp18 := new(CurrentExposureStatsCommand)
	sub = &cobra.Command{
		Use:   `stats ["/api/v1/teams/TEAM_ID/stats/exposure/current"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp18.Run(c, args) },
	}
	tmp18.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp18.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "delete",
		Short: `delete action`,
	}
	tmp19 := new(DeleteAssetsCommand)
	sub = &cobra.Command{
		Use:   `assets ["/api/v1/teams/TEAM_ID/assets/ASSET_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp19.Run(c, args) },
	}
	tmp19.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp19.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp20 := new(DeleteAssetAnnotationsCommand)
	sub = &cobra.Command{
		Use:   `asset-annotations ["/api/v1/teams/TEAM_ID/assets/ASSET_ID/annotations"]`,
		Short: ``,
		Long: `

Payload example:

{
   "annotations": [
      "annotation/1",
      "annotation/2"
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp20.Run(c, args) },
	}
	tmp20.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp20.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp21 := new(DeleteAssetGroupCommand)
	sub = &cobra.Command{
		Use:   `asset-group ["/api/v1/teams/TEAM_ID/groups/GROUP_ID/assets/ASSET_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp21.Run(c, args) },
	}
	tmp21.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp21.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp22 := new(DeleteTeamsCommand)
	sub = &cobra.Command{
		Use:   `teams ["/api/v1/teams/TEAM_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp22.Run(c, args) },
	}
	tmp22.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp22.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp23 := new(DeleteGroupCommand)
	sub = &cobra.Command{
		Use:   `group ["/api/v1/teams/TEAM_ID/groups/GROUP_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp23.Run(c, args) },
	}
	tmp23.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp23.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp24 := new(DeletePoliciesCommand)
	sub = &cobra.Command{
		Use:   `policies ["/api/v1/teams/TEAM_ID/policies/POLICY_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp24.Run(c, args) },
	}
	tmp24.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp24.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp25 := new(DeletePolicySettingsCommand)
	sub = &cobra.Command{
		Use:   `policy-settings ["/api/v1/teams/TEAM_ID/policies/POLICY_ID/settings/SETTINGS_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp25.Run(c, args) },
	}
	tmp25.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp25.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp26 := new(DeleteProgramsCommand)
	sub = &cobra.Command{
		Use:   `programs ["/api/v1/teams/TEAM_ID/programs/PROGRAM_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp26.Run(c, args) },
	}
	tmp26.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp26.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp27 := new(DeleteScheduleCommand)
	sub = &cobra.Command{
		Use:   `schedule ["/api/v1/teams/TEAM_ID/programs/PROGRAM_ID/schedule"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp27.Run(c, args) },
	}
	tmp27.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp27.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp28 := new(DeleteTeamMembersCommand)
	sub = &cobra.Command{
		Use:   `team-members ["/api/v1/teams/TEAM_ID/members/USER_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp28.Run(c, args) },
	}
	tmp28.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp28.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp29 := new(DeleteUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/v1/users/USER_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp29.Run(c, args) },
	}
	tmp29.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp29.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "discover",
		Short: `This endpoint receives a list of assets with embedded
asset annotations, and the group name where to be added. It should be used by
third-party asset discovery services to onboard the discovered assets into
Vulcan. The provided list of assets will overwrite the assets previously
present in the group, in a way that:
  - Assets that do not exist in the team will be created and associated to the
  group
  - Assets that were already existing in the team but not associated to the
  group will be associated
  - Existing assets where the scannable field or the annotations are different
  will be updated accordingly
  - Assets that were associated to the group and now are not present in the
  provided list will be de-associated from the group if they belong to any
  other group, or deleted otherwise
Because of the latency of this operation the endpoint is asynchronous. It
returns a 202-Accepted HTTP response with the Job information in the response
body.
The discovery group name must end with '-discovered-assets' to not mess with
manually managed asset groups. Also the first part of the name should identify
the discovery service using the endpoint, for example:
serviceX-discovered-assets.
Also be aware that the provided annotations may differ from the ones that will
be stored, because they will include a prefix to not mess with any other
annotations already present in the asset.`,
	}
	tmp30 := new(DiscoverAssetsCommand)
	sub = &cobra.Command{
		Use:   `assets ["/api/v1/teams/TEAM_ID/assets/discovery"]`,
		Short: ``,
		Long: `

Payload example:

{
   "assets": [
      {
         "alias": "AnAlias",
         "annotations": {
            "annotation/1": "value/1",
            "annotation/2": "value/2"
         },
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      },
      {
         "alias": "AnAlias",
         "annotations": {
            "annotation/1": "value/1",
            "annotation/2": "value/2"
         },
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      },
      {
         "alias": "AnAlias",
         "annotations": {
            "annotation/1": "value/1",
            "annotation/2": "value/2"
         },
         "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
         "identifier": "vulcan.example.com",
         "options": "{\"timeout\":60}",
         "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
         "scannable": true,
         "type": "Hostname"
      }
   ],
   "group_name": "discoveryserviceX-discovered-assets"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp30.Run(c, args) },
	}
	tmp30.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp30.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "email",
		Short: `Retrieve the report in html format to be sent by email.`,
	}
	tmp31 := new(EmailScanReportCommand)
	sub = &cobra.Command{
		Use:   `scan report ["/api/v1/teams/TEAM_ID/scans/SCAN_ID/report/email"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp31.Run(c, args) },
	}
	tmp31.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp31.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "exposure",
		Short: `exposure action`,
	}
	tmp32 := new(ExposureGlobalStatsCommand)
	sub = &cobra.Command{
		Use:   `global-stats ["/api/v1/stats/exposure"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp32.Run(c, args) },
	}
	tmp32.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp32.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp33 := new(ExposureStatsCommand)
	sub = &cobra.Command{
		Use:   `stats ["/api/v1/teams/TEAM_ID/stats/exposure"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp33.Run(c, args) },
	}
	tmp33.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp33.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "find-finding",
		Short: `Find a finding.`,
	}
	tmp34 := new(FindFindingFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings/FINDING_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp34.Run(c, args) },
	}
	tmp34.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp34.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "find-findings-froma-issue",
		Short: `Find all findings from a team and issue.`,
	}
	tmp35 := new(FindFindingsFromAIssueFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings/issues/ISSUE_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp35.Run(c, args) },
	}
	tmp35.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp35.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "find-findings-froma-target",
		Short: `Find all findings from a team and target.`,
	}
	tmp36 := new(FindFindingsFromATargetFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings/targets/TARGET_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp36.Run(c, args) },
	}
	tmp36.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp36.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "fixed",
		Short: `fixed action`,
	}
	tmp37 := new(FixedGlobalStatsCommand)
	sub = &cobra.Command{
		Use:   `global-stats ["/api/v1/stats/fixed"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp37.Run(c, args) },
	}
	tmp37.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp37.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp38 := new(FixedStatsCommand)
	sub = &cobra.Command{
		Use:   `stats ["/api/v1/teams/TEAM_ID/stats/fixed"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp38.Run(c, args) },
	}
	tmp38.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp38.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "generate",
		Short: `Triggers report generation. The report will be generated asynchronously on Vulcan Backend.`,
	}
	tmp39 := new(GenerateScanReportCommand)
	sub = &cobra.Command{
		Use:   `scan report ["/api/v1/teams/TEAM_ID/scans/SCAN_ID/report"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp39.Run(c, args) },
	}
	tmp39.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp39.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list",
		Short: `list action`,
	}
	tmp40 := new(ListAssetsCommand)
	sub = &cobra.Command{
		Use:   `assets ["/api/v1/teams/TEAM_ID/assets"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp40.Run(c, args) },
	}
	tmp40.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp40.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp41 := new(ListAssetAnnotationsCommand)
	sub = &cobra.Command{
		Use:   `asset-annotations ["/api/v1/teams/TEAM_ID/assets/ASSET_ID/annotations"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp41.Run(c, args) },
	}
	tmp41.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp41.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp42 := new(ListAssetGroupCommand)
	sub = &cobra.Command{
		Use:   `asset-group ["/api/v1/teams/TEAM_ID/groups/GROUP_ID/assets"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp42.Run(c, args) },
	}
	tmp42.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp42.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp43 := new(ListTeamsCommand)
	sub = &cobra.Command{
		Use:   `teams ["/api/v1/teams"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp43.Run(c, args) },
	}
	tmp43.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp43.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp44 := new(ListGroupCommand)
	sub = &cobra.Command{
		Use:   `group ["/api/v1/teams/TEAM_ID/groups"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp44.Run(c, args) },
	}
	tmp44.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp44.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp45 := new(ListPoliciesCommand)
	sub = &cobra.Command{
		Use:   `policies ["/api/v1/teams/TEAM_ID/policies"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp45.Run(c, args) },
	}
	tmp45.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp45.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp46 := new(ListPolicySettingsCommand)
	sub = &cobra.Command{
		Use:   `policy-settings ["/api/v1/teams/TEAM_ID/policies/POLICY_ID/settings"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp46.Run(c, args) },
	}
	tmp46.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp46.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp47 := new(ListProgramsCommand)
	sub = &cobra.Command{
		Use:   `programs ["/api/v1/teams/TEAM_ID/programs"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp47.Run(c, args) },
	}
	tmp47.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp47.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp48 := new(ListProgramScansCommand)
	sub = &cobra.Command{
		Use:   `program-scans ["/api/v1/teams/TEAM_ID/programs/PROGRAM_ID/scans"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp48.Run(c, args) },
	}
	tmp48.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp48.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp49 := new(ListRecipientsCommand)
	sub = &cobra.Command{
		Use:   `recipients ["/api/v1/teams/TEAM_ID/recipients"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp49.Run(c, args) },
	}
	tmp49.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp49.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp50 := new(ListTeamMembersCommand)
	sub = &cobra.Command{
		Use:   `team-members ["/api/v1/teams/TEAM_ID/members"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp50.Run(c, args) },
	}
	tmp50.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp50.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp51 := new(ListUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/v1/users"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp51.Run(c, args) },
	}
	tmp51.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp51.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-finding-overwrites",
		Short: `List Finding Overwrites.`,
	}
	tmp52 := new(ListFindingOverwritesFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings/FINDING_ID/overwrites"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp52.Run(c, args) },
	}
	tmp52.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp52.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-findings",
		Short: `List all findings from a team.`,
	}
	tmp53 := new(ListFindingsFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp53.Run(c, args) },
	}
	tmp53.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp53.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-findings-issues",
		Short: `List number of findings and max score per issue.`,
	}
	tmp54 := new(ListFindingsIssuesFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings/issues"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp54.Run(c, args) },
	}
	tmp54.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp54.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-findings-labels",
		Short: `List all findings labels.`,
	}
	tmp55 := new(ListFindingsLabelsFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings/labels"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp55.Run(c, args) },
	}
	tmp55.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp55.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-findings-targets",
		Short: `List number of findings and max score per target.`,
	}
	tmp56 := new(ListFindingsTargetsFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings/targets"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp56.Run(c, args) },
	}
	tmp56.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp56.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "list-teams",
		Short: `List all teams for an user.`,
	}
	tmp57 := new(ListTeamsUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/v1/users/USER_ID/teams"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp57.Run(c, args) },
	}
	tmp57.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp57.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "mttr",
		Short: `mttr action`,
	}
	tmp58 := new(MttrGlobalStatsCommand)
	sub = &cobra.Command{
		Use:   `global-stats ["/api/v1/stats/mttr"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp58.Run(c, args) },
	}
	tmp58.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp58.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp59 := new(MttrStatsCommand)
	sub = &cobra.Command{
		Use:   `stats ["/api/v1/teams/TEAM_ID/stats/mttr"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp59.Run(c, args) },
	}
	tmp59.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp59.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "open",
		Short: `open action`,
	}
	tmp60 := new(OpenGlobalStatsCommand)
	sub = &cobra.Command{
		Use:   `global-stats ["/api/v1/stats/open"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp60.Run(c, args) },
	}
	tmp60.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp60.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp61 := new(OpenStatsCommand)
	sub = &cobra.Command{
		Use:   `stats ["/api/v1/teams/TEAM_ID/stats/open"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp61.Run(c, args) },
	}
	tmp61.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp61.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "profile",
		Short: `Show profile information for the current authenticated user based on the key used to make the request.`,
	}
	tmp62 := new(ProfileUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/v1/profile"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp62.Run(c, args) },
	}
	tmp62.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp62.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "put",
		Short: `Override all annotations with a new list`,
	}
	tmp63 := new(PutAssetAnnotationsCommand)
	sub = &cobra.Command{
		Use:   `asset-annotations ["/api/v1/teams/TEAM_ID/assets/ASSET_ID/annotations"]`,
		Short: ``,
		Long: `

Payload example:

{
   "annotations": {
      "annotation/1": "value/1",
      "annotation/2": "value/2"
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp63.Run(c, args) },
	}
	tmp63.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp63.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "send",
		Short: `Send the generated report by email to the team recipients.`,
	}
	tmp64 := new(SendScanReportCommand)
	sub = &cobra.Command{
		Use:   `scan report ["/api/v1/teams/TEAM_ID/scans/SCAN_ID/report/send"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp64.Run(c, args) },
	}
	tmp64.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp64.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "send-digest",
		Short: `Send digest report.
If no dates are specified, the time range will be set for the last 30 days.`,
	}
	tmp65 := new(SendDigestReportCommand)
	sub = &cobra.Command{
		Use:   `report ["/api/v1/teams/TEAM_ID/report/digest"]`,
		Short: ``,
		Long: `

Payload example:

{
   "end_date": "2020-09-10",
   "start_date": "2020-08-11"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp65.Run(c, args) },
	}
	tmp65.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp65.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "show",
		Short: `show action`,
	}
	tmp66 := new(ShowAssetsCommand)
	sub = &cobra.Command{
		Use:   `assets ["/api/v1/teams/TEAM_ID/assets/ASSET_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp66.Run(c, args) },
	}
	tmp66.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp66.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp67 := new(ShowHealthcheckCommand)
	sub = &cobra.Command{
		Use:   `healthcheck ["/api/v1/healthcheck"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp67.Run(c, args) },
	}
	tmp67.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp67.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp68 := new(ShowJobsCommand)
	sub = &cobra.Command{
		Use:   `jobs ["/api/v1/jobs/JOB_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp68.Run(c, args) },
	}
	tmp68.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp68.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp69 := new(ShowTeamsCommand)
	sub = &cobra.Command{
		Use:   `teams ["/api/v1/teams/TEAM_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp69.Run(c, args) },
	}
	tmp69.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp69.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp70 := new(ShowGroupCommand)
	sub = &cobra.Command{
		Use:   `group ["/api/v1/teams/TEAM_ID/groups/GROUP_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp70.Run(c, args) },
	}
	tmp70.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp70.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp71 := new(ShowPoliciesCommand)
	sub = &cobra.Command{
		Use:   `policies ["/api/v1/teams/TEAM_ID/policies/POLICY_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp71.Run(c, args) },
	}
	tmp71.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp71.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp72 := new(ShowPolicySettingsCommand)
	sub = &cobra.Command{
		Use:   `policy-settings ["/api/v1/teams/TEAM_ID/policies/POLICY_ID/settings/SETTINGS_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp72.Run(c, args) },
	}
	tmp72.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp72.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp73 := new(ShowProgramsCommand)
	sub = &cobra.Command{
		Use:   `programs ["/api/v1/teams/TEAM_ID/programs/PROGRAM_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp73.Run(c, args) },
	}
	tmp73.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp73.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp74 := new(ShowScanCommand)
	sub = &cobra.Command{
		Use:   `scan ["/api/v1/teams/TEAM_ID/scans/SCAN_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp74.Run(c, args) },
	}
	tmp74.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp74.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp75 := new(ShowScanReportCommand)
	sub = &cobra.Command{
		Use:   `scan report ["/api/v1/teams/TEAM_ID/scans/SCAN_ID/report"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp75.Run(c, args) },
	}
	tmp75.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp75.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp76 := new(ShowTeamMembersCommand)
	sub = &cobra.Command{
		Use:   `team-members ["/api/v1/teams/TEAM_ID/members/USER_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp76.Run(c, args) },
	}
	tmp76.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp76.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp77 := new(ShowUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/v1/users/USER_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp77.Run(c, args) },
	}
	tmp77.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp77.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "submita-finding-overwrite",
		Short: `Overwrite data for a specific finding.`,
	}
	tmp78 := new(SubmitAFindingOverwriteFindingsCommand)
	sub = &cobra.Command{
		Use:   `findings ["/api/v1/teams/TEAM_ID/findings/FINDING_ID/overwrites"]`,
		Short: ``,
		Long: `

Payload example:

{
   "notes": "This is a false positive because...",
   "status": "FALSE_POSITIVE"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp78.Run(c, args) },
	}
	tmp78.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp78.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "update",
		Short: `update action`,
	}
	tmp79 := new(UpdateAssetsCommand)
	sub = &cobra.Command{
		Use:   `assets ["/api/v1/teams/TEAM_ID/assets/ASSET_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "alias": "AnAlias",
   "environmental_cvss": "AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
   "identifier": "vulcan.example.com",
   "options": "{\"timeout\":60}",
   "rolfp": "R:1/O:1/L:0/F:0/P:0+S:1",
   "scannable": true,
   "type": "Hostname"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp79.Run(c, args) },
	}
	tmp79.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp79.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp80 := new(UpdateAssetAnnotationsCommand)
	sub = &cobra.Command{
		Use:   `asset-annotations ["/api/v1/teams/TEAM_ID/assets/ASSET_ID/annotations"]`,
		Short: ``,
		Long: `

Payload example:

{
   "annotations": {
      "annotation/1": "value/1",
      "annotation/2": "value/2"
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp80.Run(c, args) },
	}
	tmp80.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp80.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp81 := new(UpdateTeamsCommand)
	sub = &cobra.Command{
		Use:   `teams ["/api/v1/teams/TEAM_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "description": "Security Team",
   "name": "Security",
   "tag": "team:security"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp81.Run(c, args) },
	}
	tmp81.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp81.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp82 := new(UpdateGroupCommand)
	sub = &cobra.Command{
		Use:   `group ["/api/v1/teams/TEAM_ID/groups/GROUP_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "name": "Default group",
   "options": "{\"timeout\":60}"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp82.Run(c, args) },
	}
	tmp82.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp82.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp83 := new(UpdatePoliciesCommand)
	sub = &cobra.Command{
		Use:   `policies ["/api/v1/teams/TEAM_ID/policies/POLICY_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "name": "Sample Policy"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp83.Run(c, args) },
	}
	tmp83.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp83.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp84 := new(UpdatePolicySettingsCommand)
	sub = &cobra.Command{
		Use:   `policy-settings ["/api/v1/teams/TEAM_ID/policies/POLICY_ID/settings/SETTINGS_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "checktype_name": "vulcan-tls",
   "options": "{\"timeout\":60}"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp84.Run(c, args) },
	}
	tmp84.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp84.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp85 := new(UpdateProgramsCommand)
	sub = &cobra.Command{
		Use:   `programs ["/api/v1/teams/TEAM_ID/programs/PROGRAM_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "autosend": true,
   "disabled": false,
   "name": "Every midnight",
   "policy_groups": [
      {
         "group_id": "Iure provident.",
         "policy_id": "Consequatur perferendis dolor."
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp85.Run(c, args) },
	}
	tmp85.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp85.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp86 := new(UpdateRecipientsCommand)
	sub = &cobra.Command{
		Use:   `recipients ["/api/v1/teams/TEAM_ID/recipients"]`,
		Short: ``,
		Long: `

Payload example:

{
   "emails": [
      "john.doe@vulcan.example.com",
      "jane.doe@vulcan.example.com"
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp86.Run(c, args) },
	}
	tmp86.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp86.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp87 := new(UpdateScheduleCommand)
	sub = &cobra.Command{
		Use:   `schedule ["/api/v1/teams/TEAM_ID/programs/PROGRAM_ID/schedule"]`,
		Short: ``,
		Long: `

Payload example:

{
   "cron": "0 7 1 * *"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp87.Run(c, args) },
	}
	tmp87.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp87.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp88 := new(UpdateTeamMembersCommand)
	sub = &cobra.Command{
		Use:   `team-members ["/api/v1/teams/TEAM_ID/members/USER_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "role": "owner"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp88.Run(c, args) },
	}
	tmp88.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp88.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp89 := new(UpdateUserCommand)
	sub = &cobra.Command{
		Use:   `user ["/api/v1/users/USER_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "active": true,
   "admin": false,
   "firstname": "John",
   "lastname": "Doe"
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp89.Run(c, args) },
	}
	tmp89.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp89.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
}

func intFlagVal(name string, parsed int) *int {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func float64FlagVal(name string, parsed float64) *float64 {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func boolFlagVal(name string, parsed bool) *bool {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func stringFlagVal(name string, parsed string) *string {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func hasFlag(name string) bool {
	for _, arg := range os.Args[1:] {
		if strings.HasPrefix(arg, "--"+name) {
			return true
		}
	}
	return false
}

func jsonVal(val string) (*interface{}, error) {
	var t interface{}
	err := json.Unmarshal([]byte(val), &t)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func jsonArray(ins []string) ([]interface{}, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []interface{}
	for _, id := range ins {
		val, err := jsonVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, val)
	}
	return vals, nil
}

func timeVal(val string) (*time.Time, error) {
	t, err := time.Parse(time.RFC3339, val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func timeArray(ins []string) ([]time.Time, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []time.Time
	for _, id := range ins {
		val, err := timeVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func uuidVal(val string) (*uuid.UUID, error) {
	t, err := uuid.FromString(val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func uuidArray(ins []string) ([]uuid.UUID, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []uuid.UUID
	for _, id := range ins {
		val, err := uuidVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func float64Val(val string) (*float64, error) {
	t, err := strconv.ParseFloat(val, 64)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func float64Array(ins []string) ([]float64, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []float64
	for _, id := range ins {
		val, err := float64Val(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func boolVal(val string) (*bool, error) {
	t, err := strconv.ParseBool(val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func boolArray(ins []string) ([]bool, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []bool
	for _, id := range ins {
		val, err := boolVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

// Run makes the HTTP request corresponding to the CreateAPITokenCommand command.
func (cmd *CreateAPITokenCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/users/%v/token", url.QueryEscape(cmd.UserID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateAPIToken(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateAPITokenCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var userID string
	cc.Flags().StringVar(&cmd.UserID, "user_id", userID, `User ID`)
}

// Run makes the HTTP request corresponding to the CreateAssetGroupCommand command.
func (cmd *CreateAssetGroupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/groups/%v/assets", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.GroupID))
	}
	var payload client.AssetGroupPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateAssetGroup(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateAssetGroupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var groupID string
	cc.Flags().StringVar(&cmd.GroupID, "group_id", groupID, `Group ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeleteAssetGroupCommand command.
func (cmd *DeleteAssetGroupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/groups/%v/assets/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.GroupID), url.QueryEscape(cmd.AssetID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteAssetGroup(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteAssetGroupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var groupID string
	cc.Flags().StringVar(&cmd.GroupID, "group_id", groupID, `Group ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListAssetGroupCommand command.
func (cmd *ListAssetGroupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/groups/%v/assets", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.GroupID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListAssetGroup(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListAssetGroupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var groupID string
	cc.Flags().StringVar(&cmd.GroupID, "group_id", groupID, `Group ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CreateAssetsCommand command.
func (cmd *CreateAssetsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets", url.QueryEscape(cmd.TeamID))
	}
	var payload client.CreateAssetPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateAssets(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateAssetsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CreateMultiStatusAssetsCommand command.
func (cmd *CreateMultiStatusAssetsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/multistatus", url.QueryEscape(cmd.TeamID))
	}
	var payload client.CreateAssetPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateMultiStatusAssets(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateMultiStatusAssetsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeleteAssetsCommand command.
func (cmd *DeleteAssetsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.AssetID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteAssets(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteAssetsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DiscoverAssetsCommand command.
func (cmd *DiscoverAssetsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/discovery", url.QueryEscape(cmd.TeamID))
	}
	var payload client.DiscoveredAssetsPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DiscoverAssets(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DiscoverAssetsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListAssetsCommand command.
func (cmd *ListAssetsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListAssets(ctx, path, stringFlagVal("identifier", cmd.Identifier))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListAssetsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var identifier string
	cc.Flags().StringVar(&cmd.Identifier, "identifier", identifier, `Identifier`)
}

// Run makes the HTTP request corresponding to the ShowAssetsCommand command.
func (cmd *ShowAssetsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.AssetID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowAssets(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowAssetsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdateAssetsCommand command.
func (cmd *UpdateAssetsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.AssetID))
	}
	var payload client.AssetUpdatePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateAssets(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateAssetsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the FindFindingFindingsCommand command.
func (cmd *FindFindingFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.FindingID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.FindFindingFindings(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *FindFindingFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var findingID string
	cc.Flags().StringVar(&cmd.FindingID, "finding_id", findingID, `Finding ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the FindFindingsFromAIssueFindingsCommand command.
func (cmd *FindFindingsFromAIssueFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings/issues/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.IssueID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp90 *float64
	if cmd.MaxScore != "" {
		var err error
		tmp90, err = float64Val(cmd.MaxScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--maxScore", "err", err)
			return err
		}
	}
	var tmp91 *float64
	if cmd.MinScore != "" {
		var err error
		tmp91, err = float64Val(cmd.MinScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--minScore", "err", err)
			return err
		}
	}
	var tmp92 *float64
	if cmd.Page != "" {
		var err error
		tmp92, err = float64Val(cmd.Page)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--page", "err", err)
			return err
		}
	}
	var tmp93 *float64
	if cmd.Size != "" {
		var err error
		tmp93, err = float64Val(cmd.Size)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--size", "err", err)
			return err
		}
	}
	resp, err := c.FindFindingsFromAIssueFindings(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), tmp90, stringFlagVal("minDate", cmd.MinDate), tmp91, tmp92, tmp93, stringFlagVal("sortBy", cmd.SortBy), stringFlagVal("status", cmd.Status))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *FindFindingsFromAIssueFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var issueID string
	cc.Flags().StringVar(&cmd.IssueID, "issue_id", issueID, `Issue ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Allows to get findings list at a specific date (incompatible and preferential to min and max date params)`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of identifiers`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Allows to get findings list until a specific date`)
	var maxScore string
	cc.Flags().StringVar(&cmd.MaxScore, "maxScore", maxScore, `Findings maximum score`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Allows to get findings list from a specific date`)
	var minScore string
	cc.Flags().StringVar(&cmd.MinScore, "minScore", minScore, `Findings minimum score`)
	var page string
	cc.Flags().StringVar(&cmd.Page, "page", page, `Requested page`)
	var size string
	cc.Flags().StringVar(&cmd.Size, "size", size, `Requested page size`)
	var sortBy string
	cc.Flags().StringVar(&cmd.SortBy, "sortBy", sortBy, `Sorting criteria. Supported fields: score, -score (for descending order)`)
	var status string
	cc.Flags().StringVar(&cmd.Status, "status", status, `Findings Status`)
}

// Run makes the HTTP request corresponding to the FindFindingsFromATargetFindingsCommand command.
func (cmd *FindFindingsFromATargetFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings/targets/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.TargetID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp94 *float64
	if cmd.MaxScore != "" {
		var err error
		tmp94, err = float64Val(cmd.MaxScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--maxScore", "err", err)
			return err
		}
	}
	var tmp95 *float64
	if cmd.MinScore != "" {
		var err error
		tmp95, err = float64Val(cmd.MinScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--minScore", "err", err)
			return err
		}
	}
	var tmp96 *float64
	if cmd.Page != "" {
		var err error
		tmp96, err = float64Val(cmd.Page)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--page", "err", err)
			return err
		}
	}
	var tmp97 *float64
	if cmd.Size != "" {
		var err error
		tmp97, err = float64Val(cmd.Size)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--size", "err", err)
			return err
		}
	}
	resp, err := c.FindFindingsFromATargetFindings(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), tmp94, stringFlagVal("minDate", cmd.MinDate), tmp95, tmp96, tmp97, stringFlagVal("sortBy", cmd.SortBy), stringFlagVal("status", cmd.Status))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *FindFindingsFromATargetFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var targetID string
	cc.Flags().StringVar(&cmd.TargetID, "target_id", targetID, `Target ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Allows to get findings list at a specific date (incompatible and preferential to min and max date params)`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of identifiers`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Allows to get findings list until a specific date`)
	var maxScore string
	cc.Flags().StringVar(&cmd.MaxScore, "maxScore", maxScore, `Findings maximum score`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Allows to get findings list from a specific date`)
	var minScore string
	cc.Flags().StringVar(&cmd.MinScore, "minScore", minScore, `Findings minimum score`)
	var page string
	cc.Flags().StringVar(&cmd.Page, "page", page, `Requested page`)
	var size string
	cc.Flags().StringVar(&cmd.Size, "size", size, `Requested page size`)
	var sortBy string
	cc.Flags().StringVar(&cmd.SortBy, "sortBy", sortBy, `Sorting criteria. Supported fields: score, -score (for descending order)`)
	var status string
	cc.Flags().StringVar(&cmd.Status, "status", status, `Findings Status`)
}

// Run makes the HTTP request corresponding to the ListFindingOverwritesFindingsCommand command.
func (cmd *ListFindingOverwritesFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings/%v/overwrites", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.FindingID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListFindingOverwritesFindings(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListFindingOverwritesFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var findingID string
	cc.Flags().StringVar(&cmd.FindingID, "finding_id", findingID, ``)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListFindingsLabelsFindingsCommand command.
func (cmd *ListFindingsLabelsFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings/labels", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListFindingsLabelsFindings(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate), stringFlagVal("status", cmd.Status))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListFindingsLabelsFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Allows to get findings list at a specific date (incompatible and preferential to min and max date params)`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of identifiers`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Allows to get findings list until a specific date`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Allows to get findings list from a specific date`)
	var status string
	cc.Flags().StringVar(&cmd.Status, "status", status, `Findings status`)
}

// Run makes the HTTP request corresponding to the SubmitAFindingOverwriteFindingsCommand command.
func (cmd *SubmitAFindingOverwriteFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings/%v/overwrites", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.FindingID))
	}
	var payload client.FindingOverwritePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.SubmitAFindingOverwriteFindings(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *SubmitAFindingOverwriteFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var findingID string
	cc.Flags().StringVar(&cmd.FindingID, "finding_id", findingID, ``)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListFindingsFindingsCommand command.
func (cmd *ListFindingsFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp98 *float64
	if cmd.MaxScore != "" {
		var err error
		tmp98, err = float64Val(cmd.MaxScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--maxScore", "err", err)
			return err
		}
	}
	var tmp99 *float64
	if cmd.MinScore != "" {
		var err error
		tmp99, err = float64Val(cmd.MinScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--minScore", "err", err)
			return err
		}
	}
	var tmp100 *float64
	if cmd.Page != "" {
		var err error
		tmp100, err = float64Val(cmd.Page)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--page", "err", err)
			return err
		}
	}
	var tmp101 *float64
	if cmd.Size != "" {
		var err error
		tmp101, err = float64Val(cmd.Size)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--size", "err", err)
			return err
		}
	}
	resp, err := c.ListFindingsFindings(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifier", cmd.Identifier), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("issueID", cmd.IssueID), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), tmp98, stringFlagVal("minDate", cmd.MinDate), tmp99, tmp100, tmp101, stringFlagVal("sortBy", cmd.SortBy), stringFlagVal("status", cmd.Status), stringFlagVal("targetID", cmd.TargetID))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListFindingsFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Allows to get findings list at a specific date (incompatible and preferential to min and max date params)`)
	var identifier string
	cc.Flags().StringVar(&cmd.Identifier, "identifier", identifier, `Allows to get findings list for a specific asset identifier`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of identifiers`)
	var issueID string
	cc.Flags().StringVar(&cmd.IssueID, "issueID", issueID, `Issue ID (Vulnerability DB)`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Allows to get findings list until a specific date`)
	var maxScore string
	cc.Flags().StringVar(&cmd.MaxScore, "maxScore", maxScore, `Findings maximum score`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Allows to get findings list from a specific date`)
	var minScore string
	cc.Flags().StringVar(&cmd.MinScore, "minScore", minScore, `Findings minimum score`)
	var page string
	cc.Flags().StringVar(&cmd.Page, "page", page, `Requested page`)
	var size string
	cc.Flags().StringVar(&cmd.Size, "size", size, `Requested page size`)
	var sortBy string
	cc.Flags().StringVar(&cmd.SortBy, "sortBy", sortBy, `Sorting criteria. Supported fields: score, -score (for descending order)`)
	var status string
	cc.Flags().StringVar(&cmd.Status, "status", status, `Findings Status`)
	var targetID string
	cc.Flags().StringVar(&cmd.TargetID, "targetID", targetID, `Target ID (Vulnerability DB)`)
}

// Run makes the HTTP request corresponding to the ListFindingsIssuesFindingsCommand command.
func (cmd *ListFindingsIssuesFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings/issues", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp102 *float64
	if cmd.Page != "" {
		var err error
		tmp102, err = float64Val(cmd.Page)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--page", "err", err)
			return err
		}
	}
	var tmp103 *float64
	if cmd.Size != "" {
		var err error
		tmp103, err = float64Val(cmd.Size)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--size", "err", err)
			return err
		}
	}
	resp, err := c.ListFindingsIssuesFindings(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate), tmp102, tmp103, stringFlagVal("sortBy", cmd.SortBy), stringFlagVal("status", cmd.Status), stringFlagVal("targetID", cmd.TargetID))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListFindingsIssuesFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Allows to get issues list at a specific date`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of identifiers`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Allows to get findings list until a specific date`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Allows to get findings list from a specific date`)
	var page string
	cc.Flags().StringVar(&cmd.Page, "page", page, `Requested page`)
	var size string
	cc.Flags().StringVar(&cmd.Size, "size", size, `Requested page size`)
	var sortBy string
	cc.Flags().StringVar(&cmd.SortBy, "sortBy", sortBy, `Sorting criteria. Supported fields: max_score, targets_count (use - for descending order. E.g.: -max_score)`)
	var status string
	cc.Flags().StringVar(&cmd.Status, "status", status, `Findings Status`)
	var targetID string
	cc.Flags().StringVar(&cmd.TargetID, "targetID", targetID, `Target ID (Vulnerability DB)`)
}

// Run makes the HTTP request corresponding to the ListFindingsTargetsFindingsCommand command.
func (cmd *ListFindingsTargetsFindingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/findings/targets", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp104 *float64
	if cmd.Page != "" {
		var err error
		tmp104, err = float64Val(cmd.Page)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--page", "err", err)
			return err
		}
	}
	var tmp105 *float64
	if cmd.Size != "" {
		var err error
		tmp105, err = float64Val(cmd.Size)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--size", "err", err)
			return err
		}
	}
	resp, err := c.ListFindingsTargetsFindings(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("issueID", cmd.IssueID), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate), tmp104, tmp105, stringFlagVal("sortBy", cmd.SortBy), stringFlagVal("status", cmd.Status))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListFindingsTargetsFindingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Allows to get targets list at a specific date`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of identifiers`)
	var issueID string
	cc.Flags().StringVar(&cmd.IssueID, "issueID", issueID, `Issue ID (Vulnerability DB)`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Allows to get findings list until a specific date`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Allows to get findings list from a specific date`)
	var page string
	cc.Flags().StringVar(&cmd.Page, "page", page, `Requested page`)
	var size string
	cc.Flags().StringVar(&cmd.Size, "size", size, `Requested page size`)
	var sortBy string
	cc.Flags().StringVar(&cmd.SortBy, "sortBy", sortBy, `Sorting criteria. Supported fields: max_score, findings_count (use - for descending order. E.g.: -max_score)`)
	var status string
	cc.Flags().StringVar(&cmd.Status, "status", status, `Findings Status`)
}

// Run makes the HTTP request corresponding to the AssetsGlobalStatsCommand command.
func (cmd *AssetsGlobalStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/stats/assets"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.AssetsGlobalStats(ctx, path, stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("labels", cmd.Labels), stringFlagVal("tags", cmd.Tags))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *AssetsGlobalStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of asset identifiers`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var tags string
	cc.Flags().StringVar(&cmd.Tags, "tags", tags, `Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.`)
}

// Run makes the HTTP request corresponding to the CurrentExposureGlobalStatsCommand command.
func (cmd *CurrentExposureGlobalStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/stats/exposure/current"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp106 *float64
	if cmd.MaxScore != "" {
		var err error
		tmp106, err = float64Val(cmd.MaxScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--maxScore", "err", err)
			return err
		}
	}
	var tmp107 *float64
	if cmd.MinScore != "" {
		var err error
		tmp107, err = float64Val(cmd.MinScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--minScore", "err", err)
			return err
		}
	}
	resp, err := c.CurrentExposureGlobalStats(ctx, path, tmp106, tmp107, stringFlagVal("tags", cmd.Tags))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CurrentExposureGlobalStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var maxScore string
	cc.Flags().StringVar(&cmd.MaxScore, "maxScore", maxScore, `Maximum issues score filter`)
	var minScore string
	cc.Flags().StringVar(&cmd.MinScore, "minScore", minScore, `Minimum issues score filter`)
	var tags string
	cc.Flags().StringVar(&cmd.Tags, "tags", tags, `Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.`)
}

// Run makes the HTTP request corresponding to the ExposureGlobalStatsCommand command.
func (cmd *ExposureGlobalStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/stats/exposure"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp108 *float64
	if cmd.MaxScore != "" {
		var err error
		tmp108, err = float64Val(cmd.MaxScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--maxScore", "err", err)
			return err
		}
	}
	var tmp109 *float64
	if cmd.MinScore != "" {
		var err error
		tmp109, err = float64Val(cmd.MinScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--minScore", "err", err)
			return err
		}
	}
	resp, err := c.ExposureGlobalStats(ctx, path, stringFlagVal("atDate", cmd.AtDate), tmp108, tmp109, stringFlagVal("tags", cmd.Tags))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ExposureGlobalStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Specific date to get statistics at`)
	var maxScore string
	cc.Flags().StringVar(&cmd.MaxScore, "maxScore", maxScore, `Maximum issues score filter`)
	var minScore string
	cc.Flags().StringVar(&cmd.MinScore, "minScore", minScore, `Minimum issues score filter`)
	var tags string
	cc.Flags().StringVar(&cmd.Tags, "tags", tags, `Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.`)
}

// Run makes the HTTP request corresponding to the FixedGlobalStatsCommand command.
func (cmd *FixedGlobalStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/stats/fixed"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.FixedGlobalStats(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate), stringFlagVal("tags", cmd.Tags))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *FixedGlobalStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Specific date to get statistics at (incompatible and preferential to min and max date params)`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of asset identifiers`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Maximum date to filter statistics by`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Minimum date to filter statistics by`)
	var tags string
	cc.Flags().StringVar(&cmd.Tags, "tags", tags, `Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.`)
}

// Run makes the HTTP request corresponding to the MttrGlobalStatsCommand command.
func (cmd *MttrGlobalStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/stats/mttr"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.MttrGlobalStats(ctx, path, stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate), stringFlagVal("tags", cmd.Tags))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *MttrGlobalStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Maximum date to filter statistics by`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Minimum date to filter statistics by`)
	var tags string
	cc.Flags().StringVar(&cmd.Tags, "tags", tags, `Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.`)
}

// Run makes the HTTP request corresponding to the OpenGlobalStatsCommand command.
func (cmd *OpenGlobalStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/stats/open"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.OpenGlobalStats(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate), stringFlagVal("tags", cmd.Tags))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *OpenGlobalStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Specific date to get statistics at (incompatible and preferential to min and max date params)`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of asset identifiers`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Maximum date to filter statistics by`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Minimum date to filter statistics by`)
	var tags string
	cc.Flags().StringVar(&cmd.Tags, "tags", tags, `Comma separated list of team tags to filter by. Only admin and observer users are allowed to set this field.`)
}

// Run makes the HTTP request corresponding to the ShowHealthcheckCommand command.
func (cmd *ShowHealthcheckCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/healthcheck"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowHealthcheck(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowHealthcheckCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
}

// Run makes the HTTP request corresponding to the CreateTeamsCommand command.
func (cmd *CreateTeamsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/teams"
	}
	var payload client.TeamPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateTeams(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateTeamsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the DeleteTeamsCommand command.
func (cmd *DeleteTeamsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteTeams(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteTeamsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListTeamsCommand command.
func (cmd *ListTeamsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/teams"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListTeams(ctx, path, stringFlagVal("tag", cmd.Tag))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListTeamsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var tag string
	cc.Flags().StringVar(&cmd.Tag, "tag", tag, `Team tag`)
}

// Run makes the HTTP request corresponding to the ShowTeamsCommand command.
func (cmd *ShowTeamsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowTeams(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowTeamsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdateTeamsCommand command.
func (cmd *UpdateTeamsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v", url.QueryEscape(cmd.TeamID))
	}
	var payload client.TeamUpdatePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateTeams(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateTeamsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `team ID`)
}

// Run makes the HTTP request corresponding to the CreateAssetAnnotationsCommand command.
func (cmd *CreateAssetAnnotationsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/%v/annotations", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.AssetID))
	}
	var payload client.AssetAnnotationRequest
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateAssetAnnotations(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateAssetAnnotationsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeleteAssetAnnotationsCommand command.
func (cmd *DeleteAssetAnnotationsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/%v/annotations", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.AssetID))
	}
	var payload client.AssetAnnotationDeleteRequest
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteAssetAnnotations(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteAssetAnnotationsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListAssetAnnotationsCommand command.
func (cmd *ListAssetAnnotationsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/%v/annotations", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.AssetID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListAssetAnnotations(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListAssetAnnotationsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the PutAssetAnnotationsCommand command.
func (cmd *PutAssetAnnotationsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/%v/annotations", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.AssetID))
	}
	var payload client.AssetAnnotationRequest
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.PutAssetAnnotations(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *PutAssetAnnotationsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdateAssetAnnotationsCommand command.
func (cmd *UpdateAssetAnnotationsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/assets/%v/annotations", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.AssetID))
	}
	var payload client.AssetAnnotationRequest
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateAssetAnnotations(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateAssetAnnotationsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var assetID string
	cc.Flags().StringVar(&cmd.AssetID, "asset_id", assetID, `Asset ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CreateGroupCommand command.
func (cmd *CreateGroupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/groups", url.QueryEscape(cmd.TeamID))
	}
	var payload client.GroupPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateGroup(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateGroupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeleteGroupCommand command.
func (cmd *DeleteGroupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/groups/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.GroupID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteGroup(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteGroupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var groupID string
	cc.Flags().StringVar(&cmd.GroupID, "group_id", groupID, `Group ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListGroupCommand command.
func (cmd *ListGroupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/groups", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListGroup(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListGroupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ShowGroupCommand command.
func (cmd *ShowGroupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/groups/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.GroupID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowGroup(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowGroupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var groupID string
	cc.Flags().StringVar(&cmd.GroupID, "group_id", groupID, `Group ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdateGroupCommand command.
func (cmd *UpdateGroupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/groups/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.GroupID))
	}
	var payload client.GroupPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateGroup(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateGroupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var groupID string
	cc.Flags().StringVar(&cmd.GroupID, "group_id", groupID, `Group ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ShowJobsCommand command.
func (cmd *ShowJobsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/jobs/%v", url.QueryEscape(cmd.JobID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowJobs(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowJobsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var jobID string
	cc.Flags().StringVar(&cmd.JobID, "job_id", jobID, `Job ID`)
}

// Run makes the HTTP request corresponding to the CreatePoliciesCommand command.
func (cmd *CreatePoliciesCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies", url.QueryEscape(cmd.TeamID))
	}
	var payload client.PolicyPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreatePolicies(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreatePoliciesCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeletePoliciesCommand command.
func (cmd *DeletePoliciesCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.PolicyID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeletePolicies(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeletePoliciesCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var policyID string
	cc.Flags().StringVar(&cmd.PolicyID, "policy_id", policyID, `Policy ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListPoliciesCommand command.
func (cmd *ListPoliciesCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListPolicies(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListPoliciesCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ShowPoliciesCommand command.
func (cmd *ShowPoliciesCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.PolicyID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowPolicies(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowPoliciesCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var policyID string
	cc.Flags().StringVar(&cmd.PolicyID, "policy_id", policyID, `Policy ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdatePoliciesCommand command.
func (cmd *UpdatePoliciesCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.PolicyID))
	}
	var payload client.PolicyUpdatePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdatePolicies(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdatePoliciesCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var policyID string
	cc.Flags().StringVar(&cmd.PolicyID, "policy_id", policyID, `Policy ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CreatePolicySettingsCommand command.
func (cmd *CreatePolicySettingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies/%v/settings", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.PolicyID))
	}
	var payload client.PolicySettingPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreatePolicySettings(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreatePolicySettingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var policyID string
	cc.Flags().StringVar(&cmd.PolicyID, "policy_id", policyID, `Policy ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeletePolicySettingsCommand command.
func (cmd *DeletePolicySettingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies/%v/settings/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.PolicyID), url.QueryEscape(cmd.SettingsID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeletePolicySettings(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeletePolicySettingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var policyID string
	cc.Flags().StringVar(&cmd.PolicyID, "policy_id", policyID, `Policy ID`)
	var settingsID string
	cc.Flags().StringVar(&cmd.SettingsID, "settings_id", settingsID, `Policy Settings ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListPolicySettingsCommand command.
func (cmd *ListPolicySettingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies/%v/settings", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.PolicyID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListPolicySettings(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListPolicySettingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var policyID string
	cc.Flags().StringVar(&cmd.PolicyID, "policy_id", policyID, `Policy ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ShowPolicySettingsCommand command.
func (cmd *ShowPolicySettingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies/%v/settings/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.PolicyID), url.QueryEscape(cmd.SettingsID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowPolicySettings(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowPolicySettingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var policyID string
	cc.Flags().StringVar(&cmd.PolicyID, "policy_id", policyID, `Policy ID`)
	var settingsID string
	cc.Flags().StringVar(&cmd.SettingsID, "settings_id", settingsID, `CheckType Settings ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdatePolicySettingsCommand command.
func (cmd *UpdatePolicySettingsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/policies/%v/settings/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.PolicyID), url.QueryEscape(cmd.SettingsID))
	}
	var payload client.PolicySettingUploadPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdatePolicySettings(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdatePolicySettingsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var policyID string
	cc.Flags().StringVar(&cmd.PolicyID, "policy_id", policyID, `Policy ID`)
	var settingsID string
	cc.Flags().StringVar(&cmd.SettingsID, "settings_id", settingsID, `Policy Settings ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CreateProgramsCommand command.
func (cmd *CreateProgramsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs", url.QueryEscape(cmd.TeamID))
	}
	var payload client.ProgramPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreatePrograms(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateProgramsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeleteProgramsCommand command.
func (cmd *DeleteProgramsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ProgramID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeletePrograms(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteProgramsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var programID string
	cc.Flags().StringVar(&cmd.ProgramID, "program_id", programID, `Program ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListProgramsCommand command.
func (cmd *ListProgramsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListPrograms(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListProgramsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ShowProgramsCommand command.
func (cmd *ShowProgramsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ProgramID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowPrograms(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowProgramsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var programID string
	cc.Flags().StringVar(&cmd.ProgramID, "program_id", programID, `Program ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdateProgramsCommand command.
func (cmd *UpdateProgramsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ProgramID))
	}
	var payload client.ProgramUpdatePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdatePrograms(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateProgramsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var programID string
	cc.Flags().StringVar(&cmd.ProgramID, "program_id", programID, `Program ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListProgramScansCommand command.
func (cmd *ListProgramScansCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs/%v/scans", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ProgramID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListProgramScans(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListProgramScansCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var programID string
	cc.Flags().StringVar(&cmd.ProgramID, "program_id", programID, `Program ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ListRecipientsCommand command.
func (cmd *ListRecipientsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/recipients", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListRecipients(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListRecipientsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdateRecipientsCommand command.
func (cmd *UpdateRecipientsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/recipients", url.QueryEscape(cmd.TeamID))
	}
	var payload client.RecipientsPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateRecipients(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateRecipientsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the SendDigestReportCommand command.
func (cmd *SendDigestReportCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/report/digest", url.QueryEscape(cmd.TeamID))
	}
	var payload client.DigestPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.SendDigestReport(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *SendDigestReportCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CreateScanCommand command.
func (cmd *CreateScanCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/scans", url.QueryEscape(cmd.TeamID))
	}
	var payload client.ScanPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateScan(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateScanCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ShowScanCommand command.
func (cmd *ShowScanCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/scans/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ScanID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowScan(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowScanCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var scanID string
	cc.Flags().StringVar(&cmd.ScanID, "scan_id", scanID, `Scan ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the EmailScanReportCommand command.
func (cmd *EmailScanReportCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/scans/%v/report/email", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ScanID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.EmailScanReport(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *EmailScanReportCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var scanID string
	cc.Flags().StringVar(&cmd.ScanID, "scan_id", scanID, `Scan ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the GenerateScanReportCommand command.
func (cmd *GenerateScanReportCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/scans/%v/report", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ScanID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GenerateScanReport(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GenerateScanReportCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var scanID string
	cc.Flags().StringVar(&cmd.ScanID, "scan_id", scanID, `Scan ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the SendScanReportCommand command.
func (cmd *SendScanReportCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/scans/%v/report/send", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ScanID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.SendScanReport(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *SendScanReportCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var scanID string
	cc.Flags().StringVar(&cmd.ScanID, "scan_id", scanID, `Scan ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ShowScanReportCommand command.
func (cmd *ShowScanReportCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/scans/%v/report", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ScanID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowScanReport(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowScanReportCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var scanID string
	cc.Flags().StringVar(&cmd.ScanID, "scan_id", scanID, `Scan ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CreateScheduleCommand command.
func (cmd *CreateScheduleCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs/%v/schedule", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ProgramID))
	}
	var payload client.SchedulePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateSchedule(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateScheduleCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var programID string
	cc.Flags().StringVar(&cmd.ProgramID, "program_id", programID, `Program ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeleteScheduleCommand command.
func (cmd *DeleteScheduleCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs/%v/schedule", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ProgramID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteSchedule(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteScheduleCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var programID string
	cc.Flags().StringVar(&cmd.ProgramID, "program_id", programID, `Program ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the UpdateScheduleCommand command.
func (cmd *UpdateScheduleCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/programs/%v/schedule", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.ProgramID))
	}
	var payload client.ScheduleUpdatePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateSchedule(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateScheduleCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var programID string
	cc.Flags().StringVar(&cmd.ProgramID, "program_id", programID, `Program ID`)
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CoverageStatsCommand command.
func (cmd *CoverageStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/stats/coverage", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CoverageStats(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CoverageStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the CurrentExposureStatsCommand command.
func (cmd *CurrentExposureStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/stats/exposure/current", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp110 *float64
	if cmd.MaxScore != "" {
		var err error
		tmp110, err = float64Val(cmd.MaxScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--maxScore", "err", err)
			return err
		}
	}
	var tmp111 *float64
	if cmd.MinScore != "" {
		var err error
		tmp111, err = float64Val(cmd.MinScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--minScore", "err", err)
			return err
		}
	}
	resp, err := c.CurrentExposureStats(ctx, path, tmp110, tmp111)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CurrentExposureStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var maxScore string
	cc.Flags().StringVar(&cmd.MaxScore, "maxScore", maxScore, `Maximum issues score filter`)
	var minScore string
	cc.Flags().StringVar(&cmd.MinScore, "minScore", minScore, `Minimum issues score filter`)
}

// Run makes the HTTP request corresponding to the ExposureStatsCommand command.
func (cmd *ExposureStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/stats/exposure", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp112 *float64
	if cmd.MaxScore != "" {
		var err error
		tmp112, err = float64Val(cmd.MaxScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--maxScore", "err", err)
			return err
		}
	}
	var tmp113 *float64
	if cmd.MinScore != "" {
		var err error
		tmp113, err = float64Val(cmd.MinScore)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *float64 value", "flag", "--minScore", "err", err)
			return err
		}
	}
	resp, err := c.ExposureStats(ctx, path, stringFlagVal("atDate", cmd.AtDate), tmp112, tmp113)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ExposureStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Specific date to get statistics at`)
	var maxScore string
	cc.Flags().StringVar(&cmd.MaxScore, "maxScore", maxScore, `Maximum issues score filter`)
	var minScore string
	cc.Flags().StringVar(&cmd.MinScore, "minScore", minScore, `Minimum issues score filter`)
}

// Run makes the HTTP request corresponding to the FixedStatsCommand command.
func (cmd *FixedStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/stats/fixed", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.FixedStats(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *FixedStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Specific date to get statistics at (incompatible and preferential to min and max date params)`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of asset identifiers`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Maximum date to filter statistics by`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Minimum date to filter statistics by`)
}

// Run makes the HTTP request corresponding to the MttrStatsCommand command.
func (cmd *MttrStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/stats/mttr", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.MttrStats(ctx, path, stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *MttrStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Maximum date to filter statistics by`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Minimum date to filter statistics by`)
}

// Run makes the HTTP request corresponding to the OpenStatsCommand command.
func (cmd *OpenStatsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/stats/open", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.OpenStats(ctx, path, stringFlagVal("atDate", cmd.AtDate), stringFlagVal("identifiers", cmd.Identifiers), stringFlagVal("labels", cmd.Labels), stringFlagVal("maxDate", cmd.MaxDate), stringFlagVal("minDate", cmd.MinDate))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *OpenStatsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var atDate string
	cc.Flags().StringVar(&cmd.AtDate, "atDate", atDate, `Specific date to get statistics at (incompatible and preferential to min and max date params)`)
	var identifiers string
	cc.Flags().StringVar(&cmd.Identifiers, "identifiers", identifiers, `A comma separated list of asset identifiers`)
	var labels string
	cc.Flags().StringVar(&cmd.Labels, "labels", labels, `A comma separated list of associated labels`)
	var maxDate string
	cc.Flags().StringVar(&cmd.MaxDate, "maxDate", maxDate, `Maximum date to filter statistics by`)
	var minDate string
	cc.Flags().StringVar(&cmd.MinDate, "minDate", minDate, `Minimum date to filter statistics by`)
}

// Run makes the HTTP request corresponding to the CreateTeamMembersCommand command.
func (cmd *CreateTeamMembersCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/members", url.QueryEscape(cmd.TeamID))
	}
	var payload client.TeamMemberPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateTeamMembers(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateTeamMembersCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the DeleteTeamMembersCommand command.
func (cmd *DeleteTeamMembersCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/members/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.UserID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteTeamMembers(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteTeamMembersCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var userID string
	cc.Flags().StringVar(&cmd.UserID, "user_id", userID, `User ID`)
}

// Run makes the HTTP request corresponding to the ListTeamMembersCommand command.
func (cmd *ListTeamMembersCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/members", url.QueryEscape(cmd.TeamID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListTeamMembers(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListTeamMembersCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
}

// Run makes the HTTP request corresponding to the ShowTeamMembersCommand command.
func (cmd *ShowTeamMembersCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/members/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.UserID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowTeamMembers(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowTeamMembersCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var userID string
	cc.Flags().StringVar(&cmd.UserID, "user_id", userID, `User ID`)
}

// Run makes the HTTP request corresponding to the UpdateTeamMembersCommand command.
func (cmd *UpdateTeamMembersCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/teams/%v/members/%v", url.QueryEscape(cmd.TeamID), url.QueryEscape(cmd.UserID))
	}
	var payload client.TeamMemberUpdatePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateTeamMembers(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateTeamMembersCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var teamID string
	cc.Flags().StringVar(&cmd.TeamID, "team_id", teamID, `Team ID`)
	var userID string
	cc.Flags().StringVar(&cmd.UserID, "user_id", userID, `User ID`)
}

// Run makes the HTTP request corresponding to the CreateUserCommand command.
func (cmd *CreateUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/users"
	}
	var payload client.UserPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateUser(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the DeleteUserCommand command.
func (cmd *DeleteUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/users/%v", url.QueryEscape(cmd.UserID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteUser(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var userID string
	cc.Flags().StringVar(&cmd.UserID, "user_id", userID, `User ID`)
}

// Run makes the HTTP request corresponding to the ListUserCommand command.
func (cmd *ListUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/users"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListUser(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
}

// Run makes the HTTP request corresponding to the ListTeamsUserCommand command.
func (cmd *ListTeamsUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/users/%v/teams", url.QueryEscape(cmd.UserID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ListTeamsUser(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ListTeamsUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var userID string
	cc.Flags().StringVar(&cmd.UserID, "user_id", userID, `User ID`)
}

// Run makes the HTTP request corresponding to the ProfileUserCommand command.
func (cmd *ProfileUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/api/v1/profile"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ProfileUser(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ProfileUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
}

// Run makes the HTTP request corresponding to the ShowUserCommand command.
func (cmd *ShowUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/users/%v", url.QueryEscape(cmd.UserID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ShowUser(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ShowUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var userID string
	cc.Flags().StringVar(&cmd.UserID, "user_id", userID, `User ID`)
}

// Run makes the HTTP request corresponding to the UpdateUserCommand command.
func (cmd *UpdateUserCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/api/v1/users/%v", url.QueryEscape(cmd.UserID))
	}
	var payload client.UserUpdatePayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.UpdateUser(ctx, path, &payload)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *UpdateUserCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var userID string
	cc.Flags().StringVar(&cmd.UserID, "user_id", userID, `User ID`)
}
