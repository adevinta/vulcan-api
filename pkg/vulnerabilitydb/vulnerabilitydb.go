/*
Copyright 2021 Adevinta
*/

package vulnerabilitydb

import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/adevinta/errors"
	"github.com/adevinta/vulcan-api/pkg/api"
)

const (
	// FindingStatusOpen defines the open status of a finding in the vulnerabilitydb.
	FindingStatusOpen = "OPEN"

	//FindingStatusFixed defines the fixed status of finding in the vulnerabilitydb.
	FindingStatusFixed = "FIXED"

	issuesPath               = "/issues"
	findingsPath             = "/findings"
	findingPath              = "/findings/%s"
	findingsIssuesPath       = "/issues/summary"
	findingsByIssuePath      = "/issues/%s/findings"
	findingsTargetsPath      = "/targets/summary"
	findingsByTargetPath     = "/targets/%s/findings"
	targetsPath              = "/targets"
	targetsTeamPath          = "/targets/%s/teams/%s"
	teamsPath                = "/targets/teams/%s"
	statsMTTRPath            = "/stats/mttr"
	statsExposurePath        = "/stats/exposure"
	statsCurrentExposurePath = "/stats/exposure/current"
	statsOpenPath            = "/stats/open"
	statsFixedPath           = "/stats/fixed"
	statsAssetsPath          = "/stats/assets"
	labelsPath               = "/labels"

	teamFilter            = "team"
	teamsFilter           = "teams"
	statusFilter          = "status"
	minScoreFilter        = "minScore"
	maxScoreFilter        = "maxScore"
	atDateFilter          = "atDate"
	minDateFilter         = "minDate"
	maxDateFilter         = "maxDate"
	sortByFilter          = "sortBy"
	pageFilter            = "page"
	sizeFilter            = "size"
	issueIDFilter         = "issueID"
	targetIDFilter        = "targetID"
	identifierFilter      = "identifier"
	identifierMatchFilter = "identifiermatch"
	identifiersFilter     = "identifiers"
	labelsFilter          = "labels"

	authScheme = "TEAM team=%s"
	noAuth     = ""
)

// Client defines the shape of the vulndb client needed by the api.
type Client interface {
	Issues(ctx context.Context, pagination api.Pagination) (*api.IssuesList, error)
	Findings(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsList, error)
	Finding(ctx context.Context, findingID string) (*api.Finding, error)
	UpdateFinding(ctx context.Context, findingID string, payload *api.UpdateFinding, team string) (*api.Finding, error)
	FindingsIssues(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsIssuesList, error)
	FindingsByIssue(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsList, error)
	FindingsTargets(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsTargetsList, error)
	FindingsByTarget(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsList, error)
	Targets(ctx context.Context, params api.TargetsParams, pagination api.Pagination) (*api.TargetsList, error)
	CreateTarget(ctx context.Context, payload api.CreateTarget) (*api.Target, error)
	DeleteTargetTeam(ctx context.Context, authTeam, targetID, teamID string) error
	DeleteTeam(ctx context.Context, authTeam, teamID string) error
	StatsMTTR(ctx context.Context, params api.StatsParams) (*api.StatsMTTR, error)
	StatsExposure(ctx context.Context, params api.StatsParams) (*api.StatsExposure, error)
	StatsCurrentExposure(ctx context.Context, params api.StatsParams) (*api.StatsCurrentExposure, error)
	StatsOpen(ctx context.Context, params api.StatsParams) (*api.StatsOpen, error)
	StatsFixed(ctx context.Context, params api.StatsParams) (*api.StatsFixed, error)
	StatsAssets(ctx context.Context, params api.StatsParams) (*api.StatsAssets, error)
	Labels(ctx context.Context, params api.FindingsParams) (*api.FindingsLabels, error)
}

type client struct {
	baseURL    string
	httpClient *http.Client
}

// NewClient returns a new Vulnerabilitydb client with the given config and httpClient.
func NewClient(httpClient *http.Client, baseURL string, insecureTLS bool) Client {
	if httpClient == nil {
		httpClient = &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: insecureTLS, // nolint
				},
			},
		}
	}
	return &client{
		httpClient: httpClient,
		baseURL:    baseURL,
	}
}

// Issues returns all the issues in the vulnerabilitydb.
func (c *client) Issues(ctx context.Context, pagination api.Pagination) (*api.IssuesList, error) {
	queryParams := make(map[string]string)
	parsePaginationQuery(queryParams, pagination)

	resp, err := c.performRequest(ctx, http.MethodGet, issuesPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var issues api.IssuesList
	err = json.Unmarshal(resp, &issues)
	return &issues, err
}

// Findings returns all the findings of targets, the method allows to specify a
// team/s and/or a status.
func (c *client) Findings(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsList, error) {
	queryParams := make(map[string]string)
	parseFindingsQuery(queryParams, params)
	parsePaginationQuery(queryParams, pagination)

	resp, err := c.performRequest(ctx, http.MethodGet, findingsPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var findings api.FindingsList
	err = json.Unmarshal(resp, &findings)
	return &findings, err
}

// Finding returns a finding.
func (c *client) Finding(ctx context.Context, findingID string) (*api.Finding, error) {
	resp, err := c.performRequest(ctx, http.MethodGet, fmt.Sprintf(findingPath, findingID), noAuth, nil, nil)
	if err != nil {
		return nil, err
	}

	var finding api.Finding
	err = json.Unmarshal(resp, &finding)
	return &finding, err
}

// UpdateFinding updates a finding and returns a finding.
func (c *client) UpdateFinding(ctx context.Context, findingID string, payload *api.UpdateFinding, team string) (*api.Finding, error) {
	data, err := json.Marshal(&payload)
	if err != nil {
		return nil, err
	}

	resp, err := c.performRequest(ctx, http.MethodPatch, fmt.Sprintf(findingPath, findingID), team, nil, data)
	if err != nil {
		return nil, err
	}

	var findingResponse api.Finding
	err = json.Unmarshal(resp, &findingResponse)
	return &findingResponse, err
}

// FindingsIssue returns all the findings of targets related to an
// issue, the method allows to specify a team and/or a status.
func (c *client) FindingsByIssue(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsList, error) {
	queryParams := make(map[string]string)
	parseFindingsQuery(queryParams, params)
	delete(queryParams, issueIDFilter)
	parsePaginationQuery(queryParams, pagination)

	resp, err := c.performRequest(ctx, http.MethodGet, fmt.Sprintf(findingsByIssuePath, params.IssueID), noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var findings api.FindingsList
	err = json.Unmarshal(resp, &findings)
	return &findings, err
}

// FindingsIssues returns the list of issues summary for the specified request parameters.
func (c *client) FindingsIssues(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsIssuesList, error) {
	queryParams := make(map[string]string)
	parseFindingsQuery(queryParams, params)
	parsePaginationQuery(queryParams, pagination)

	resp, err := c.performRequest(ctx, http.MethodGet, findingsIssuesPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var findingsIssues api.FindingsIssuesList
	err = json.Unmarshal(resp, &findingsIssues)
	return &findingsIssues, err
}

// FindingsTarget returns all the findings of targets related to an
// issue, the method allows to specify a team and/or a status.
func (c *client) FindingsByTarget(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsList, error) {
	queryParams := make(map[string]string)
	parseFindingsQuery(queryParams, params)
	delete(queryParams, targetIDFilter)
	parsePaginationQuery(queryParams, pagination)

	resp, err := c.performRequest(ctx, http.MethodGet, fmt.Sprintf(findingsByTargetPath, params.TargetID), noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var findings api.FindingsList
	err = json.Unmarshal(resp, &findings)
	return &findings, err
}

// FindingsTargets returns the list of targets summary for the specified request parameters.
func (c *client) FindingsTargets(ctx context.Context, params api.FindingsParams, pagination api.Pagination) (*api.FindingsTargetsList, error) {
	queryParams := make(map[string]string)
	parseFindingsQuery(queryParams, params)
	parsePaginationQuery(queryParams, pagination)

	resp, err := c.performRequest(ctx, http.MethodGet, findingsTargetsPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var findingsTargets api.FindingsTargetsList
	err = json.Unmarshal(resp, &findingsTargets)
	return &findingsTargets, err
}

// Targets returns the list of targets for the specified request parameters.
func (c *client) Targets(ctx context.Context, params api.TargetsParams, pagination api.Pagination) (*api.TargetsList, error) {
	queryParams := make(map[string]string)
	parseTargetsQuery(queryParams, params)
	parsePaginationQuery(queryParams, pagination)

	resp, err := c.performRequest(ctx, http.MethodGet, targetsPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var targetsList api.TargetsList
	err = json.Unmarshal(resp, &targetsList)
	return &targetsList, err
}

// CreateTarget requests the creation of the specified target and associated teams.
func (c *client) CreateTarget(ctx context.Context, payload api.CreateTarget) (*api.Target, error) {
	data, err := json.Marshal(payload)
	if err != nil {
		return nil, err
	}

	resp, err := c.performRequest(ctx, http.MethodPost, targetsPath, noAuth, nil, data)
	if err != nil {
		return nil, err
	}

	var targetResponse api.Target
	err = json.Unmarshal(resp, &targetResponse)
	return &targetResponse, err
}

// DeleteTargetTeam removes the given team for the given target.
func (c *client) DeleteTargetTeam(ctx context.Context, authTeam, targetID, teamID string) error {
	queryParams := make(map[string]string)
	_, err := c.performRequest(ctx, http.MethodDelete, fmt.Sprintf(targetsTeamPath, targetID, teamID), authTeam, queryParams, nil)
	return err
}

// DeleteTeam removes all association with targets for the given team.
func (c *client) DeleteTeam(ctx context.Context, authTeam, teamID string) error {
	queryParams := make(map[string]string)
	_, err := c.performRequest(ctx, http.MethodDelete, fmt.Sprintf(teamsPath, teamID), authTeam, queryParams, nil)
	return err
}

// StatsMTTR returns the mean time to remediate for a specific team or teams.
func (c *client) StatsMTTR(ctx context.Context, params api.StatsParams) (*api.StatsMTTR, error) {
	queryParams := make(map[string]string)
	parseStatsQuery(queryParams, params)

	resp, err := c.performRequest(ctx, http.MethodGet, statsMTTRPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var statsMTTR api.StatsMTTR
	err = json.Unmarshal(resp, &statsMTTR)
	return &statsMTTR, err
}

// StatsExposure returns different averages for the exposure time of findings for a specific team.
// The endpoint also allows including only findings above or below specific scores in the calculation.
func (c *client) StatsExposure(ctx context.Context, params api.StatsParams) (*api.StatsExposure, error) {
	queryParams := make(map[string]string)
	parseStatsQuery(queryParams, params)

	resp, err := c.performRequest(ctx, http.MethodGet, statsExposurePath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var statsExposure api.StatsExposure
	err = json.Unmarshal(resp, &statsExposure)
	return &statsExposure, err
}

// StatsCurrentExposure returns different averages for the current exposure
// time of findings for a specific a team or teams. The endpoint also allows
// including only findings above or below specific scores in the calculation.
func (c *client) StatsCurrentExposure(ctx context.Context, params api.StatsParams) (*api.StatsCurrentExposure, error) {
	queryParams := make(map[string]string)
	parseStatsQuery(queryParams, params)

	resp, err := c.performRequest(ctx, http.MethodGet, statsCurrentExposurePath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var statsCurrExposure api.StatsCurrentExposure
	err = json.Unmarshal(resp, &statsCurrExposure)
	return &statsCurrExposure, err
}

// StatsOpen returns the stats for open findings in the vulndb.
func (c *client) StatsOpen(ctx context.Context, params api.StatsParams) (*api.StatsOpen, error) {
	queryParams := make(map[string]string)
	parseStatsQuery(queryParams, params)

	resp, err := c.performRequest(ctx, http.MethodGet, statsOpenPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var statsOpen api.StatsOpen
	err = json.Unmarshal(resp, &statsOpen)
	return &statsOpen, err
}

// StatsFixed returns the stats for fixed findings in the vulndb.
func (c *client) StatsFixed(ctx context.Context, params api.StatsParams) (*api.StatsFixed, error) {
	queryParams := make(map[string]string)
	parseStatsQuery(queryParams, params)

	resp, err := c.performRequest(ctx, http.MethodGet, statsFixedPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var statsFixed api.StatsFixed
	err = json.Unmarshal(resp, &statsFixed)
	return &statsFixed, err
}

// StatsAssets returns the stats for assets per severity in the vulndb.
func (c *client) StatsAssets(ctx context.Context, params api.StatsParams) (*api.StatsAssets, error) {
	queryParams := make(map[string]string)
	parseStatsQuery(queryParams, params)

	resp, err := c.performRequest(ctx, http.MethodGet, statsAssetsPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var statsAssets api.StatsAssets
	err = json.Unmarshal(resp, &statsAssets)
	return &statsAssets, err
}

// Labels returns all vulnerability DB labels according to query params.
func (c *client) Labels(ctx context.Context, params api.FindingsParams) (*api.FindingsLabels, error) {
	queryParams := make(map[string]string)
	parseFindingsQuery(queryParams, params)

	resp, err := c.performRequest(ctx, http.MethodGet, labelsPath, noAuth, queryParams, nil)
	if err != nil {
		return nil, err
	}

	var labels api.FindingsLabels
	err = json.Unmarshal(resp, &labels)
	return &labels, err
}

// parseFindingsQuery parses the input FindingsParams and modifies the given
// queryParams map to include the parameters that have a set value.
func parseFindingsQuery(queryParams map[string]string, params api.FindingsParams) {
	if params.Team != "" {
		queryParams[teamFilter] = params.Team
	}

	if params.Status != "" {
		queryParams[statusFilter] = params.Status
	}
	if params.MinScore != 0 {
		queryParams[minScoreFilter] = fmt.Sprintf("%.1f", params.MinScore)
	}
	if params.MaxScore != 0 {
		queryParams[maxScoreFilter] = fmt.Sprintf("%.1f", params.MaxScore)
	}
	if params.AtDate != "" {
		queryParams[atDateFilter] = params.AtDate
	}
	if params.MinDate != "" {
		queryParams[minDateFilter] = params.MinDate
	}
	if params.MaxDate != "" {
		queryParams[maxDateFilter] = params.MaxDate
	}
	if params.SortBy != "" {
		queryParams[sortByFilter] = params.SortBy
	}
	if params.IssueID != "" {
		queryParams[issueIDFilter] = params.IssueID
	}
	if params.TargetID != "" {
		queryParams[targetIDFilter] = params.TargetID
	}
	if params.Identifier != "" {
		queryParams[identifierFilter] = params.Identifier
	}
	if params.IdentifierMatch == true {
		queryParams[identifierMatchFilter] = "true"
	}
	if params.Identifiers != "" {
		queryParams[identifiersFilter] = params.Identifiers
	}
	if params.Labels != "" {
		queryParams[labelsFilter] = params.Labels
	}
}

// parseTargetsQuery parses the input TargetsParams and modifies the given
// queryParams map to include the parameters that have a set value.
func parseTargetsQuery(queryParams map[string]string, params api.TargetsParams) {
	if params.Team != "" {
		queryParams[teamFilter] = params.Team
	}
	if params.Identifier != "" {
		queryParams[identifierFilter] = params.Identifier
	}
	if params.IdentifierMatch == true {
		queryParams[identifierMatchFilter] = "true"
	}
}

// parseStatsQuery parses the input StatsParams and modifies the given queryParams
// map to include the parameters that have a set value.
func parseStatsQuery(queryParams map[string]string, params api.StatsParams) {
	if params.Team != "" {
		queryParams[teamFilter] = params.Team
	}
	if params.Teams != "" {
		queryParams[teamsFilter] = params.Teams
	}
	if params.MinDate != "" {
		queryParams[minDateFilter] = params.MinDate
	}
	if params.MaxDate != "" {
		queryParams[maxDateFilter] = params.MaxDate
	}
	if params.MinScore != 0 {
		queryParams[minScoreFilter] = fmt.Sprintf("%.1f", params.MinScore)
	}
	if params.MaxScore != 0 {
		queryParams[maxScoreFilter] = fmt.Sprintf("%.1f", params.MaxScore)
	}
	if params.AtDate != "" {
		queryParams[atDateFilter] = params.AtDate
	}
	if params.Identifiers != "" {
		queryParams[identifiersFilter] = params.Identifiers
	}
	if params.Labels != "" {
		queryParams[labelsFilter] = params.Labels
	}
}

// parsePaginationQuery parses the input pagination data and modifies the given
// queryParams map to include the parameters that have a set value.
func parsePaginationQuery(queryParams map[string]string, pagination api.Pagination) {
	if pagination.Page != 0 {
		page := strconv.Itoa(pagination.Page)
		queryParams[pageFilter] = page
	}
	if pagination.Size != 0 {
		size := strconv.Itoa(pagination.Size)
		queryParams[sizeFilter] = size
	}
}

func (c *client) performRequest(ctx context.Context, method, path, authTeam string, params map[string]string, payload []byte) ([]byte, error) {
	u, err := url.Parse(c.baseURL)
	if err != nil {
		return nil, err
	}
	u.Path = path
	u.RawQuery = buildFilter(params)

	req, err := http.NewRequest(method, u.String(), bytes.NewBuffer(payload))
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)

	if authTeam != noAuth {
		req.Header.Set("Authorization", fmt.Sprintf(authScheme, authTeam))
	}

	if payload != nil {
		req.Header.Set("Content-type", "application/json")
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	if !isStatusOk(resp.StatusCode) {
		content, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}

		return nil, parseErr(resp.StatusCode, string(content))
	}

	return ioutil.ReadAll(resp.Body)
}

func isStatusOk(status int) bool {
	return status >= http.StatusOK && status < http.StatusMultipleChoices
}

func buildFilter(filters map[string]string) string {
	filterParts := []string{}
	for key, value := range filters {
		part := fmt.Sprintf("%s=%s", key, value)
		filterParts = append(filterParts, part)
	}
	return strings.Join(filterParts, "&")
}

func parseErr(statusCode int, mssg string) error {
	switch statusCode {
	case http.StatusBadRequest:
		return errors.Assertion(mssg)
	case http.StatusUnauthorized:
		return errors.Unauthorized(mssg)
	case http.StatusForbidden:
		return errors.Forbidden(mssg)
	case http.StatusNotFound:
		return errors.NotFound(mssg)
	case http.StatusMethodNotAllowed:
		return errors.MethodNotAllowed(mssg)
	case http.StatusUnprocessableEntity:
		return errors.Validation(mssg)
	default:
		return errors.Default(mssg)
	}
}
