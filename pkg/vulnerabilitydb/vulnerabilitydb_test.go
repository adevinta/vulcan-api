/*
Copyright 2021 Adevinta
*/

package vulnerabilitydb

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"reflect"
	"testing"

	"github.com/adevinta/errors"
	"github.com/adevinta/vulcan-api/pkg/api"
	vulndb "github.com/adevinta/vulnerability-db-api/pkg/model"
)

var (
	mockFindings = &api.FindingsList{
		Findings:   []vulndb.FindingExpanded{},
		Pagination: api.PaginationInfo{},
	}

	mockTarget = &api.Target{
		Target: vulndb.Target{
			ID:         "mockID",
			Identifier: "mocktarget.com",
			Tags:       []string{"mocktag"},
		},
	}

	mockTargets = &api.TargetsList{
		Targets:    []vulndb.Target{},
		Pagination: api.PaginationInfo{},
	}

	mockStatsMTTR = &api.StatsMTTR{
		MTTR: vulndb.StatsMTTRSeverity{
			Total:         30.0,
			Critical:      10.5,
			High:          12.9,
			Medium:        27.23,
			Low:           55.01,
			Informational: 0,
		},
	}

	mockStatsOpen = &api.StatsOpen{
		OpenIssues: vulndb.StatsIssueSeverity{
			Critical:      2,
			High:          6,
			Medium:        0,
			Low:           13,
			Informational: 10,
		},
	}

	mockStatsFixed = &api.StatsFixed{
		FixedIssues: vulndb.StatsIssueSeverity{
			Critical:      8,
			High:          20,
			Medium:        18,
			Low:           19,
			Informational: 3,
		},
	}
)

type srvErr struct {
	statusCode int
	mssg       string
}

func TestFindings(t *testing.T) {
	type args struct {
		ctx        context.Context
		params     api.FindingsParams
		pagination api.Pagination
	}

	ctx := context.Background()

	tests := []struct {
		name          string
		args          args
		srvErr        *srvErr
		expectedQuery string
		expectedErr   error
	}{
		{
			name: "Happy path",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag: "tag1",
				},
				pagination: api.Pagination{
					Page: 0,
					Size: 0,
				},
			},
			srvErr:        nil,
			expectedQuery: "tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Status filter",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag1",
					Status: "FIXED",
				},
				pagination: api.Pagination{
					Page: 1,
					Size: 10,
				},
			},
			srvErr:        nil,
			expectedQuery: "page=1&size=10&status=FIXED&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Min and Max score filters",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:      "tag1",
					MinScore: 4.0,
					MaxScore: 8.9,
				},
				pagination: api.Pagination{
					Page: 1,
					Size: 10,
				},
			},
			srvErr:        nil,
			expectedQuery: "maxScore=8.9&minScore=4.0&page=1&size=10&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "AtDate filter",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag1",
					AtDate: "2019-08-01",
				},
				pagination: api.Pagination{
					Page: 1,
					Size: 10,
				},
			},
			srvErr:        nil,
			expectedQuery: "atDate=2019-08-01&page=1&size=10&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Min and Max date filters",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:     "tag1",
					MinDate: "2019-06-01",
					MaxDate: "2019-10-01",
				},
				pagination: api.Pagination{
					Page: 1,
					Size: 10,
				},
			},
			srvErr:        nil,
			expectedQuery: "maxDate=2019-10-01&minDate=2019-06-01&page=1&size=10&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Sorting filter, score asc",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag1",
					SortBy: "score",
				},
				pagination: api.Pagination{
					Page: 0,
					Size: 20,
				},
			},
			srvErr:        nil,
			expectedQuery: "size=20&sortBy=score&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Sorting filter, score desc",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag1",
					SortBy: "-score",
				},
				pagination: api.Pagination{
					Page: 0,
					Size: 20,
				},
			},
			srvErr:        nil,
			expectedQuery: "size=20&sortBy=-score&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Should return 400 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag2",
					Status: "OPEN",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusBadRequest,
				mssg:       "400 Err",
			},
			expectedQuery: "page=100&size=5&status=OPEN&tag=tag2",
			expectedErr:   errors.Assertion("400 Err"),
		},
		{
			name: "Should return 401 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag2",
					Status: "OPEN",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnauthorized,
				mssg:       "401 Err",
			},
			expectedQuery: "page=100&size=5&status=OPEN&tag=tag2",
			expectedErr:   errors.Unauthorized("401 Err"),
		},
		{
			name: "Should return 403 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag2",
					Status: "OPEN",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusForbidden,
				mssg:       "403 Err",
			},
			expectedQuery: "page=100&size=5&status=OPEN&tag=tag2",
			expectedErr:   errors.Forbidden("403 Err"),
		},
		{
			name: "Should return 404 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag2",
					Status: "OPEN",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusNotFound,
				mssg:       "404 Err",
			},
			expectedQuery: "page=100&size=5&status=OPEN&tag=tag2",
			expectedErr:   errors.NotFound("404 Err"),
		},
		{
			name: "Should return 405 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag2",
					Status: "OPEN",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusMethodNotAllowed,
				mssg:       "405 Err",
			},
			expectedQuery: "page=100&size=5&status=OPEN&tag=tag2",
			expectedErr:   errors.MethodNotAllowed("405 Err"),
		},
		{
			name: "Should return 422 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag2",
					Status: "OPEN",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnprocessableEntity,
				mssg:       "422 Err",
			},
			expectedQuery: "page=100&size=5&status=OPEN&tag=tag2",
			expectedErr:   errors.Validation("422 Err"),
		},
		{
			name: "Should return 500 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.FindingsParams{
					Tag:    "tag2",
					Status: "OPEN",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusInternalServerError,
				mssg:       "500 Err",
			},
			expectedQuery: "page=100&size=5&status=OPEN&tag=tag2",
			expectedErr:   errors.Default("500 Err"),
		},
	}

	for _, tt := range tests {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				t.Fatalf("Expected http method to be GET, but got: %s", r.Method)
			}

			queryString := r.URL.Query().Encode()
			if queryString != tt.expectedQuery {
				t.Fatalf("Expecting query string as '%s', but got '%s", tt.expectedQuery, queryString)
			}

			var httpStatus int
			var resp []byte

			if tt.srvErr != nil {
				httpStatus = tt.srvErr.statusCode
				resp = []byte(tt.srvErr.mssg)
			} else {
				httpStatus = http.StatusOK
				resp, _ = json.Marshal(mockFindings)
			}

			w.WriteHeader(httpStatus)
			w.Write(resp) // nolint
		}))

		client := NewClient(nil, server.URL, true)

		resp, err := client.Findings(tt.args.ctx, tt.args.params, tt.args.pagination)
		if !reflect.DeepEqual(err, tt.expectedErr) {
			if tt.expectedErr == nil {
				t.Fatalf("No error expected, but got '%v'", err)
			} else {
				t.Fatalf("Expecting error '%v', but got '%v'", tt.expectedErr, err)
			}
		}
		if err == nil && !reflect.DeepEqual(resp, mockFindings) {
			t.Errorf("Expected response body as:\n%v\nBut got:\n%v", mockFindings, resp)
		}

		server.Close()
	}
}

func TestStatsMTTR(t *testing.T) {
	type args struct {
		ctx    context.Context
		params api.StatsParams
	}

	ctx := context.Background()

	tests := []struct {
		name          string
		args          args
		srvErr        *srvErr
		expectedQuery string
		expectedErr   error
	}{
		{
			name: "Happy path",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag: "tag1",
				},
			},
			srvErr:        nil,
			expectedQuery: "tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Happy path with date filter",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag1",
					MinDate: "2019-06-30",
					MaxDate: "2019-08-01",
				},
			},
			srvErr:        nil,
			expectedQuery: "maxDate=2019-08-01&minDate=2019-06-30&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Should return 400 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusBadRequest,
				mssg:       "400 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Assertion("400 Err"),
		},
		{
			name: "Should return 401 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnauthorized,
				mssg:       "401 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Unauthorized("401 Err"),
		},
		{
			name: "Should return 403 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusForbidden,
				mssg:       "403 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Forbidden("403 Err"),
		},
		{
			name: "Should return 404 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusNotFound,
				mssg:       "404 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.NotFound("404 Err"),
		},
		{
			name: "Should return 405 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusMethodNotAllowed,
				mssg:       "405 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.MethodNotAllowed("405 Err"),
		},
		{
			name: "Should return 422 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnprocessableEntity,
				mssg:       "422 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Validation("422 Err"),
		},
		{
			name: "Should return 500 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusInternalServerError,
				mssg:       "500 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Default("500 Err"),
		},
	}

	for _, tt := range tests {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				t.Fatalf("Expected http method to be GET, but got: %s", r.Method)
			}

			queryString := r.URL.Query().Encode()
			if queryString != tt.expectedQuery {
				t.Fatalf("Expecting query string as '%s', but got '%s", tt.expectedQuery, queryString)
			}

			var httpStatus int
			var resp []byte

			if tt.srvErr != nil {
				httpStatus = tt.srvErr.statusCode
				resp = []byte(tt.srvErr.mssg)
			} else {
				httpStatus = http.StatusOK
				resp, _ = json.Marshal(mockStatsMTTR)
			}

			w.WriteHeader(httpStatus)
			w.Write(resp) // nolint
		}))

		client := NewClient(nil, server.URL, true)

		resp, err := client.StatsMTTR(tt.args.ctx, tt.args.params)
		if !reflect.DeepEqual(err, tt.expectedErr) {
			if tt.expectedErr == nil {
				t.Fatalf("No error expected, but got '%v'", err)
			} else {
				t.Fatalf("Expecting error '%v', but got '%v'", tt.expectedErr, err)
			}
		}
		if err == nil && !reflect.DeepEqual(resp, mockStatsMTTR) {
			t.Errorf("Expected response body as:\n%v\nBut got:\n%v", mockStatsMTTR, resp)
		}

		server.Close()
	}
}

func TestStatsOpen(t *testing.T) {
	type args struct {
		ctx    context.Context
		params api.StatsParams
	}

	ctx := context.Background()

	tests := []struct {
		name          string
		args          args
		srvErr        *srvErr
		expectedQuery string
		expectedErr   error
	}{
		{
			name: "Happy path",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag: "tag1",
				},
			},
			srvErr:        nil,
			expectedQuery: "tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Happy path with date filter",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag1",
					MinDate: "2019-06-30",
					MaxDate: "2019-08-01",
				},
			},
			srvErr:        nil,
			expectedQuery: "maxDate=2019-08-01&minDate=2019-06-30&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Happy path with atDate filter",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:    "tag1",
					AtDate: "2019-06-05",
				},
			},
			srvErr:        nil,
			expectedQuery: "atDate=2019-06-05&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Should return 400 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusBadRequest,
				mssg:       "400 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Assertion("400 Err"),
		},
		{
			name: "Should return 401 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnauthorized,
				mssg:       "401 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Unauthorized("401 Err"),
		},
		{
			name: "Should return 403 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusForbidden,
				mssg:       "403 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Forbidden("403 Err"),
		},
		{
			name: "Should return 404 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusNotFound,
				mssg:       "404 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.NotFound("404 Err"),
		},
		{
			name: "Should return 405 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusMethodNotAllowed,
				mssg:       "405 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.MethodNotAllowed("405 Err"),
		},
		{
			name: "Should return 422 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnprocessableEntity,
				mssg:       "422 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Validation("422 Err"),
		},
		{
			name: "Should return 500 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusInternalServerError,
				mssg:       "500 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Default("500 Err"),
		},
	}

	for _, tt := range tests {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				t.Fatalf("Expected http method to be GET, but got: %s", r.Method)
			}

			queryString := r.URL.Query().Encode()
			if queryString != tt.expectedQuery {
				t.Fatalf("Expecting query string as '%s', but got '%s", tt.expectedQuery, queryString)
			}

			var httpStatus int
			var resp []byte

			if tt.srvErr != nil {
				httpStatus = tt.srvErr.statusCode
				resp = []byte(tt.srvErr.mssg)
			} else {
				httpStatus = http.StatusOK
				resp, _ = json.Marshal(mockStatsOpen)
			}

			w.WriteHeader(httpStatus)
			w.Write(resp) // nolint
		}))

		client := NewClient(nil, server.URL, true)

		resp, err := client.StatsOpen(tt.args.ctx, tt.args.params)
		if !reflect.DeepEqual(err, tt.expectedErr) {
			if tt.expectedErr == nil {
				t.Fatalf("No error expected, but got '%v'", err)
			} else {
				t.Fatalf("Expecting error '%v', but got '%v'", tt.expectedErr, err)
			}
		}
		if err == nil && !reflect.DeepEqual(resp, mockStatsOpen) {
			t.Errorf("Expected response body as:\n%v\nBut got:\n%v", mockStatsOpen, resp)
		}

		server.Close()
	}
}

func TestStatsFixed(t *testing.T) {
	type args struct {
		ctx    context.Context
		params api.StatsParams
	}

	ctx := context.Background()

	tests := []struct {
		name          string
		args          args
		srvErr        *srvErr
		expectedQuery string
		expectedErr   error
	}{
		{
			name: "Happy path",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag: "tag1",
				},
			},
			srvErr:        nil,
			expectedQuery: "tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Happy path with date filter",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag1",
					MinDate: "2019-06-30",
					MaxDate: "2019-08-01",
				},
			},
			srvErr:        nil,
			expectedQuery: "maxDate=2019-08-01&minDate=2019-06-30&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Happy path with atDate filter",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:    "tag1",
					AtDate: "2019-06-05",
				},
			},
			srvErr:        nil,
			expectedQuery: "atDate=2019-06-05&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Should return 400 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusBadRequest,
				mssg:       "400 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Assertion("400 Err"),
		},
		{
			name: "Should return 401 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnauthorized,
				mssg:       "401 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Unauthorized("401 Err"),
		},
		{
			name: "Should return 403 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusForbidden,
				mssg:       "403 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Forbidden("403 Err"),
		},
		{
			name: "Should return 404 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusNotFound,
				mssg:       "404 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.NotFound("404 Err"),
		},
		{
			name: "Should return 405 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusMethodNotAllowed,
				mssg:       "405 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.MethodNotAllowed("405 Err"),
		},
		{
			name: "Should return 422 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnprocessableEntity,
				mssg:       "422 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Validation("422 Err"),
		},
		{
			name: "Should return 500 error from vulndb",
			args: args{
				ctx: ctx,
				params: api.StatsParams{
					Tag:     "tag2",
					MinDate: "2016-05-22",
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusInternalServerError,
				mssg:       "500 Err",
			},
			expectedQuery: "minDate=2016-05-22&tag=tag2",
			expectedErr:   errors.Default("500 Err"),
		},
	}

	for _, tt := range tests {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				t.Fatalf("Expected http method to be GET, but got: %s", r.Method)
			}

			queryString := r.URL.Query().Encode()
			if queryString != tt.expectedQuery {
				t.Fatalf("Expecting query string as '%s', but got '%s", tt.expectedQuery, queryString)
			}

			var httpStatus int
			var resp []byte

			if tt.srvErr != nil {
				httpStatus = tt.srvErr.statusCode
				resp = []byte(tt.srvErr.mssg)
			} else {
				httpStatus = http.StatusOK
				resp, _ = json.Marshal(mockStatsFixed)
			}

			w.WriteHeader(httpStatus)
			w.Write(resp) // nolint
		}))

		client := NewClient(nil, server.URL, true)

		resp, err := client.StatsFixed(tt.args.ctx, tt.args.params)
		if !reflect.DeepEqual(err, tt.expectedErr) {
			if tt.expectedErr == nil {
				t.Fatalf("No error expected, but got '%v'", err)
			} else {
				t.Fatalf("Expecting error '%v', but got '%v'", tt.expectedErr, err)
			}
		}
		if err == nil && !reflect.DeepEqual(resp, mockStatsFixed) {
			t.Errorf("Expected response body as:\n%v\nBut got:\n%v", mockStatsFixed, resp)
		}

		server.Close()
	}
}

func TestTargets(t *testing.T) {
	type args struct {
		ctx        context.Context
		params     api.TargetsParams
		pagination api.Pagination
	}

	ctx := context.Background()

	tests := []struct {
		name          string
		args          args
		srvErr        *srvErr
		expectedQuery string
		expectedErr   error
	}{
		{
			name: "Happy path",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag: "tag1",
				},
				pagination: api.Pagination{
					Page: 0,
					Size: 0,
				},
			},
			srvErr:        nil,
			expectedQuery: "tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Identifier filter",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag:        "tag1",
					Identifier: "identf",
				},
				pagination: api.Pagination{
					Page: 1,
					Size: 10,
				},
			},
			srvErr:        nil,
			expectedQuery: "identifier=identf&page=1&size=10&tag=tag1",
			expectedErr:   nil,
		}, {
			name: "Identifier match filter",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag:             "tag1",
					Identifier:      "identf",
					IdentifierMatch: true,
				},
				pagination: api.Pagination{
					Page: 1,
					Size: 10,
				},
			},
			srvErr:        nil,
			expectedQuery: "identifier=identf&identifiermatch=true&page=1&size=10&tag=tag1",
			expectedErr:   nil,
		},
		{
			name: "Should return 400 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag: "tag2",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusBadRequest,
				mssg:       "400 Err",
			},
			expectedQuery: "page=100&size=5&tag=tag2",
			expectedErr:   errors.Assertion("400 Err"),
		},
		{
			name: "Should return 401 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag:        "tag2",
					Identifier: "test",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnauthorized,
				mssg:       "401 Err",
			},
			expectedQuery: "identifier=test&page=100&size=5&tag=tag2",
			expectedErr:   errors.Unauthorized("401 Err"),
		},
		{
			name: "Should return 403 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag: "tag2",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusForbidden,
				mssg:       "403 Err",
			},
			expectedQuery: "page=100&size=5&tag=tag2",
			expectedErr:   errors.Forbidden("403 Err"),
		},
		{
			name: "Should return 404 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag: "tag2",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusNotFound,
				mssg:       "404 Err",
			},
			expectedQuery: "page=100&size=5&tag=tag2",
			expectedErr:   errors.NotFound("404 Err"),
		},
		{
			name: "Should return 405 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag: "tag2",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusMethodNotAllowed,
				mssg:       "405 Err",
			},
			expectedQuery: "page=100&size=5&tag=tag2",
			expectedErr:   errors.MethodNotAllowed("405 Err"),
		},
		{
			name: "Should return 422 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag: "tag2",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnprocessableEntity,
				mssg:       "422 Err",
			},
			expectedQuery: "page=100&size=5&tag=tag2",
			expectedErr:   errors.Validation("422 Err"),
		},
		{
			name: "Should return 500 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				params: api.TargetsParams{
					Tag: "tag2",
				},
				pagination: api.Pagination{
					Page: 100,
					Size: 5,
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusInternalServerError,
				mssg:       "500 Err",
			},
			expectedQuery: "page=100&size=5&tag=tag2",
			expectedErr:   errors.Default("500 Err"),
		},
	}

	for _, tt := range tests {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				t.Fatalf("Expected http method to be GET, but got: %s", r.Method)
			}

			queryString := r.URL.Query().Encode()
			if queryString != tt.expectedQuery {
				t.Fatalf("Expecting query string as '%s', but got '%s", tt.expectedQuery, queryString)
			}

			var httpStatus int
			var resp []byte

			if tt.srvErr != nil {
				httpStatus = tt.srvErr.statusCode
				resp = []byte(tt.srvErr.mssg)
			} else {
				httpStatus = http.StatusOK
				resp, _ = json.Marshal(mockTargets)
			}

			w.WriteHeader(httpStatus)
			w.Write(resp) // nolint
		}))

		client := NewClient(nil, server.URL, true)

		resp, err := client.Targets(tt.args.ctx, tt.args.params, tt.args.pagination)
		if !reflect.DeepEqual(err, tt.expectedErr) {
			if tt.expectedErr == nil {
				t.Fatalf("No error expected, but got '%v'", err)
			} else {
				t.Fatalf("Expecting error '%v', but got '%v'", tt.expectedErr, err)
			}
		}
		if err == nil && !reflect.DeepEqual(resp, mockTargets) {
			t.Errorf("Expected response body as:\n%v\nBut got:\n%v", mockTargets, resp)
		}

		server.Close()
	}
}

func TestCreateTarget(t *testing.T) {
	type args struct {
		ctx     context.Context
		payload api.CreateTarget
	}

	ctx := context.Background()

	tests := []struct {
		name        string
		args        args
		srvErr      *srvErr
		expectedErr error
	}{
		{
			name: "Happy path",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
					Tags:       []string{"mytag"},
				},
			},
			srvErr:      nil,
			expectedErr: nil,
		},
		{
			name: "Target with no tag",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
				},
			},
			srvErr:      nil,
			expectedErr: nil,
		},
		{
			name: "Should return 400 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
					Tags:       []string{"tag"},
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusBadRequest,
				mssg:       "400 Err",
			},
			expectedErr: errors.Assertion("400 Err"),
		},
		{
			name: "Should return 401 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
					Tags:       []string{"tag"},
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnauthorized,
				mssg:       "401 Err",
			},
			expectedErr: errors.Unauthorized("401 Err"),
		},
		{
			name: "Should return 403 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
					Tags:       []string{"tag"},
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusForbidden,
				mssg:       "403 Err",
			},
			expectedErr: errors.Forbidden("403 Err"),
		},
		{
			name: "Should return 404 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
					Tags:       []string{"tag"},
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusNotFound,
				mssg:       "404 Err",
			},
			expectedErr: errors.NotFound("404 Err"),
		},
		{
			name: "Should return 405 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
					Tags:       []string{"tag"},
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusMethodNotAllowed,
				mssg:       "405 Err",
			},
			expectedErr: errors.MethodNotAllowed("405 Err"),
		},
		{
			name: "Should return 422 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
					Tags:       []string{"tag"},
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnprocessableEntity,
				mssg:       "422 Err",
			},
			expectedErr: errors.Validation("422 Err"),
		},
		{
			name: "Should return 500 error from the vulnerability DB",
			args: args{
				ctx: ctx,
				payload: api.CreateTarget{
					Identifier: "example.com",
					Tags:       []string{"tag"},
				},
			},
			srvErr: &srvErr{
				statusCode: http.StatusInternalServerError,
				mssg:       "500 Err",
			},
			expectedErr: errors.Default("500 Err"),
		},
	}

	for _, tt := range tests {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.URL.Path != targetsPath {
				t.Fatalf("expected path to be /targets, but got: %s", r.URL.Path)
			}
			if r.Method != http.MethodPost {
				t.Fatalf("expected http method to be POST, but got: %s", r.Method)
			}

			var httpStatus int
			var resp []byte

			if tt.srvErr != nil {
				httpStatus = tt.srvErr.statusCode
				resp = []byte(tt.srvErr.mssg)
			} else {
				httpStatus = http.StatusOK
				resp, _ = json.Marshal(mockTarget)
			}

			w.WriteHeader(httpStatus)
			w.Write(resp) // nolint
		}))

		client := NewClient(nil, server.URL, true)

		resp, err := client.CreateTarget(tt.args.ctx, tt.args.payload)
		if !reflect.DeepEqual(err, tt.expectedErr) {
			if tt.expectedErr == nil {
				t.Fatalf("No error expected, but got '%v'", err)
			} else {
				t.Fatalf("Expecting error '%v', but got '%v'", tt.expectedErr, err)
			}
		}
		if err == nil && !reflect.DeepEqual(resp, mockTarget) {
			t.Errorf("Expected response body as:\n%v\nBut got:\n%v", mockTarget, resp)
		}

		server.Close()
	}
}

func TestDeleteTargetTag(t *testing.T) {
	type args struct {
		ctx      context.Context
		authTag  string
		targetID string
		reqTag   string
	}

	ctx := context.Background()

	tests := []struct {
		name         string
		args         args
		srvErr       *srvErr
		expectedPath string
		expectedErr  error
	}{
		{
			name: "Happy path",
			args: args{
				ctx:      ctx,
				authTag:  "authTag1",
				targetID: "targetID1",
				reqTag:   "reqTag1",
			},
			expectedPath: "/targets/targetID1/tags/reqTag1",
		},
		{
			name: "Should return 400 error from the vulnerability DB",
			args: args{
				ctx:      ctx,
				authTag:  "authTag2",
				targetID: "targetID2",
				reqTag:   "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusBadRequest,
				mssg:       "400 Err",
			},
			expectedPath: "/targets/targetID2/tags/reqTag2",
			expectedErr:  errors.Assertion("400 Err"),
		},
		{
			name: "Should return 401 error from the vulnerability DB",
			args: args{
				ctx:      ctx,
				authTag:  "authTag2",
				targetID: "targetID2",
				reqTag:   "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnauthorized,
				mssg:       "401 Err",
			},
			expectedPath: "/targets/targetID2/tags/reqTag2",
			expectedErr:  errors.Unauthorized("401 Err"),
		},
		{
			name: "Should return 403 error from the vulnerability DB",
			args: args{
				ctx:      ctx,
				authTag:  "authTag2",
				targetID: "targetID2",
				reqTag:   "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusForbidden,
				mssg:       "403 Err",
			},
			expectedPath: "/targets/targetID2/tags/reqTag2",
			expectedErr:  errors.Forbidden("403 Err"),
		},
		{
			name: "Should return 404 error from the vulnerability DB",
			args: args{
				ctx:      ctx,
				authTag:  "authTag2",
				targetID: "targetID2",
				reqTag:   "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusNotFound,
				mssg:       "404 Err",
			},
			expectedPath: "/targets/targetID2/tags/reqTag2",
			expectedErr:  errors.NotFound("404 Err"),
		},
		{
			name: "Should return 405 error from the vulnerability DB",
			args: args{
				ctx:      ctx,
				authTag:  "authTag2",
				targetID: "targetID2",
				reqTag:   "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusMethodNotAllowed,
				mssg:       "405 Err",
			},
			expectedPath: "/targets/targetID2/tags/reqTag2",
			expectedErr:  errors.MethodNotAllowed("405 Err"),
		},
		{
			name: "Should return 422 error from the vulnerability DB",
			args: args{
				ctx:      ctx,
				authTag:  "authTag2",
				targetID: "targetID2",
				reqTag:   "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnprocessableEntity,
				mssg:       "422 Err",
			},
			expectedPath: "/targets/targetID2/tags/reqTag2",
			expectedErr:  errors.Validation("422 Err"),
		},
		{
			name: "Should return 500 error from the vulnerability DB",
			args: args{
				ctx:      ctx,
				authTag:  "authTag2",
				targetID: "targetID2",
				reqTag:   "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusInternalServerError,
				mssg:       "500 Err",
			},
			expectedPath: "/targets/targetID2/tags/reqTag2",
			expectedErr:  errors.Default("500 Err"),
		},
	}

	for _, tt := range tests {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodDelete {
				t.Fatalf("Expected http method to be DELETE, but got: %s", r.Method)
			}

			reqPath := r.URL.Path
			if reqPath != tt.expectedPath {
				t.Fatalf("Expecting req path to be '%s', but got '%s'", tt.expectedPath, reqPath)
			}

			authH := r.Header.Get("Authorization")
			expectedAuthH := fmt.Sprintf("TAG tag=%s", tt.args.authTag)
			if authH != expectedAuthH {
				t.Fatalf("Expected req auth header to be '%s', but got '%s'", expectedAuthH, authH)
			}

			var httpStatus int
			var resp []byte

			if tt.srvErr != nil {
				httpStatus = tt.srvErr.statusCode
				resp = []byte(tt.srvErr.mssg)
			} else {
				httpStatus = http.StatusOK
				resp, _ = json.Marshal(mockTargets)
			}

			w.WriteHeader(httpStatus)
			w.Write(resp) // nolint
		}))

		client := NewClient(nil, server.URL, true)

		err := client.DeleteTargetTag(tt.args.ctx, tt.args.authTag, tt.args.targetID, tt.args.reqTag)
		if !reflect.DeepEqual(err, tt.expectedErr) {
			if tt.expectedErr == nil {
				t.Fatalf("No error expected, but got '%v'", err)
			} else {
				t.Fatalf("Expecting error '%v', but got '%v'", tt.expectedErr, err)
			}
		}

		server.Close()
	}
}

func TestDeleteTag(t *testing.T) {
	type args struct {
		ctx     context.Context
		authTag string
		reqTag  string
	}

	ctx := context.Background()

	tests := []struct {
		name         string
		args         args
		srvErr       *srvErr
		expectedPath string
		expectedErr  error
	}{
		{
			name: "Happy path",
			args: args{
				ctx:     ctx,
				authTag: "authTag1",
				reqTag:  "reqTag1",
			},
			expectedPath: "/targets/tags/reqTag1",
		},
		{
			name: "Should return 400 error from the vulnerability DB",
			args: args{
				ctx:     ctx,
				authTag: "authTag2",
				reqTag:  "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusBadRequest,
				mssg:       "400 Err",
			},
			expectedPath: "/targets/tags/reqTag2",
			expectedErr:  errors.Assertion("400 Err"),
		},
		{
			name: "Should return 401 error from the vulnerability DB",
			args: args{
				ctx:     ctx,
				authTag: "authTag2",
				reqTag:  "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnauthorized,
				mssg:       "401 Err",
			},
			expectedPath: "/targets/tags/reqTag2",
			expectedErr:  errors.Unauthorized("401 Err"),
		},
		{
			name: "Should return 403 error from the vulnerability DB",
			args: args{
				ctx:     ctx,
				authTag: "authTag2",
				reqTag:  "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusForbidden,
				mssg:       "403 Err",
			},
			expectedPath: "/targets/tags/reqTag2",
			expectedErr:  errors.Forbidden("403 Err"),
		},
		{
			name: "Should return 404 error from the vulnerability DB",
			args: args{
				ctx:     ctx,
				authTag: "authTag2",
				reqTag:  "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusNotFound,
				mssg:       "404 Err",
			},
			expectedPath: "/targets/tags/reqTag2",
			expectedErr:  errors.NotFound("404 Err"),
		},
		{
			name: "Should return 405 error from the vulnerability DB",
			args: args{
				ctx:     ctx,
				authTag: "authTag2",
				reqTag:  "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusMethodNotAllowed,
				mssg:       "405 Err",
			},
			expectedPath: "/targets/tags/reqTag2",
			expectedErr:  errors.MethodNotAllowed("405 Err"),
		},
		{
			name: "Should return 422 error from the vulnerability DB",
			args: args{
				ctx:     ctx,
				authTag: "authTag2",
				reqTag:  "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusUnprocessableEntity,
				mssg:       "422 Err",
			},
			expectedPath: "/targets/tags/reqTag2",
			expectedErr:  errors.Validation("422 Err"),
		},
		{
			name: "Should return 500 error from the vulnerability DB",
			args: args{
				ctx:     ctx,
				authTag: "authTag2",
				reqTag:  "reqTag2",
			},
			srvErr: &srvErr{
				statusCode: http.StatusInternalServerError,
				mssg:       "500 Err",
			},
			expectedPath: "/targets/tags/reqTag2",
			expectedErr:  errors.Default("500 Err"),
		},
	}

	for _, tt := range tests {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodDelete {
				t.Fatalf("Expected http method to be DELETE, but got: %s", r.Method)
			}

			reqPath := r.URL.Path
			if reqPath != tt.expectedPath {
				t.Fatalf("Expecting req path to be '%s', but got '%s'", tt.expectedPath, reqPath)
			}

			authH := r.Header.Get("Authorization")
			expectedAuthH := fmt.Sprintf("TAG tag=%s", tt.args.authTag)
			if authH != expectedAuthH {
				t.Fatalf("Expected req auth header to be '%s', but got '%s'", expectedAuthH, authH)
			}

			var httpStatus int
			var resp []byte

			if tt.srvErr != nil {
				httpStatus = tt.srvErr.statusCode
				resp = []byte(tt.srvErr.mssg)
			} else {
				httpStatus = http.StatusOK
				resp, _ = json.Marshal(mockTargets)
			}

			w.WriteHeader(httpStatus)
			w.Write(resp) // nolint
		}))

		client := NewClient(nil, server.URL, true)

		err := client.DeleteTag(tt.args.ctx, tt.args.authTag, tt.args.reqTag)
		if !reflect.DeepEqual(err, tt.expectedErr) {
			if tt.expectedErr == nil {
				t.Fatalf("No error expected, but got '%v'", err)
			} else {
				t.Fatalf("Expecting error '%v', but got '%v'", tt.expectedErr, err)
			}
		}

		server.Close()
	}
}
